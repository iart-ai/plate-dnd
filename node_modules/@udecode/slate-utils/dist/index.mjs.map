{"version":3,"sources":["../src/queries/findDescendant.ts","../src/queries/getBlockAbove.ts","../src/queries/getChildren.ts","../src/queries/getEdgeBlocksAbove.ts","../src/queries/getLastChild.ts","../src/queries/getLastNodeByLevel.ts","../src/queries/getMark.ts","../src/queries/getNextNodeStartPoint.ts","../src/queries/getNextSiblingNodes.ts","../src/queries/getOperations.ts","../src/queries/getPointBeforeLocation.ts","../src/queries/isRangeAcrossBlocks.ts","../src/queries/getPointFromLocation.ts","../src/queries/getPointNextToVoid.ts","../src/queries/getPreviousBlockById.ts","../src/queries/getPreviousNodeEndPoint.ts","../src/queries/getPreviousPath.ts","../src/queries/getPreviousSiblingNode.ts","../src/queries/getRangeBefore.ts","../src/queries/getRangeFromBlockStart.ts","../src/queries/getSelectionText.ts","../src/queries/isAncestorEmpty.ts","../src/queries/isBlockAboveEmpty.ts","../src/queries/isBlockTextEmptyAfterSelection.ts","../src/queries/isDocumentEnd.ts","../src/queries/isEditorEmpty.ts","../src/queries/isFirstChild.ts","../src/queries/isMarkActive.ts","../src/queries/isPointAtWordEnd.ts","../src/queries/isRangeInSameBlock.ts","../src/queries/isRangeInSingleText.ts","../src/queries/isSelectionAtBlockEnd.ts","../src/queries/isSelectionAtBlockStart.ts","../src/queries/isSelectionExpanded.ts","../src/queries/isTextByPath.ts","../src/queries/isWordAfterTrigger.ts","../src/queries/queryEditor.ts","../src/transforms/insertElements.ts","../src/transforms/insertEmptyElement.ts","../src/transforms/moveChildren.ts","../src/transforms/removeMark.ts","../src/transforms/removeSelectionMark.ts","../src/transforms/replaceNode.ts","../src/transforms/replaceNodeChildren.ts","../src/transforms/removeNodeChildren.ts","../src/transforms/selectEndOfBlockAboveSelection.ts","../src/transforms/setMarks.ts","../src/transforms/toggleMark.ts","../src/transforms/toggleWrapNodes.ts","../src/transforms/wrapNodeChildren.ts","../src/utils/createDocumentNode.ts","../src/utils/createNode.ts"],"sourcesContent":["/**\n * Iterate through all of the nodes in the editor and return the first match. If\n * no match is found, return undefined.\n */\nimport {\n  EDescendant,\n  ENodeEntry,\n  FindNodeOptions,\n  getNodeDescendants,\n  getNodeEntry,\n  getPath,\n  isVoid,\n  match,\n  TEditor,\n  TNodeEntry,\n  Value,\n} from '@udecode/slate';\nimport { Path, Range, Span } from 'slate';\n\n/**\n * Get the first descendant node matching the condition.\n */\nexport const findDescendant = <\n  N extends EDescendant<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  options: FindNodeOptions<V>\n): TNodeEntry<N> | undefined => {\n  // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.\n  try {\n    const {\n      match: _match,\n      at = editor.selection,\n      reverse = false,\n      voids = false,\n    } = options;\n\n    if (!at) return;\n\n    let from;\n    let to;\n    if (Span.isSpan(at)) {\n      [from, to] = at;\n    } else if (Range.isRange(at)) {\n      const first = getPath(editor, at, { edge: 'start' });\n      const last = getPath(editor, at, { edge: 'end' });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    let root: ENodeEntry<V> = [editor, []];\n    if (Path.isPath(at)) {\n      root = getNodeEntry(editor, at) as any;\n    }\n\n    const nodeEntries = getNodeDescendants<N>(root[0], {\n      reverse,\n      from,\n      to,\n      pass: ([n]) => (voids ? false : isVoid(editor, n)),\n    });\n\n    for (const [node, path] of nodeEntries) {\n      if (match(node, path, _match as any)) {\n        return [node, (at as Path).concat(path)];\n      }\n    }\n  } catch (error) {\n    return undefined;\n  }\n};\n","import {\n  EAncestor,\n  getAboveNode,\n  GetAboveNodeOptions,\n  TEditor,\n  Value,\n} from '@udecode/slate';\n\n/**\n * Get the block above a location (default: selection).\n */\nexport const getBlockAbove = <N extends EAncestor<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options: GetAboveNodeOptions<V> = {}\n) =>\n  getAboveNode<N, V>(editor, {\n    ...options,\n    block: true,\n  });\n","import { ChildOf, isAncestor, TNode, TNodeEntry } from '@udecode/slate';\nimport { Path } from 'slate';\n\n/**\n * Get children node entries of a node entry.\n * TODO: try Node.children\n */\nexport const getChildren = <N extends ChildOf<R>, R extends TNode = TNode>(\n  nodeEntry: TNodeEntry<R>\n): TNodeEntry<N>[] => {\n  const [node, path] = nodeEntry;\n\n  if (isAncestor(node)) {\n    const { children } = node;\n\n    return children.map((child, index) => {\n      const childPath: Path = path.concat([index]);\n      return [child as N, childPath];\n    });\n  }\n\n  return [];\n};\n","import {\n  EAncestor,\n  GetAboveNodeOptions,\n  getEdgePoints,\n  TEditor,\n  TNodeEntry,\n  Value,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * Get the edge blocks above a location (default: selection).\n */\nexport const getEdgeBlocksAbove = <\n  N1 extends EAncestor<V>,\n  N2 extends EAncestor<V> = N1,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  { at: _at, ...options }: GetAboveNodeOptions<V> = {}\n): [TNodeEntry<N1>, TNodeEntry<N2>] | null => {\n  const at = _at ?? editor.selection;\n  if (!at) return null;\n\n  const [start, end] = getEdgePoints(editor, at ?? editor.selection);\n\n  const startBlock = getBlockAbove<N1>(editor, {\n    at: start,\n    ...options,\n  });\n  if (!startBlock) return null;\n\n  const endBlock = getBlockAbove<N2>(editor, {\n    at: end,\n    ...options,\n  });\n  if (!endBlock) return null;\n\n  return [startBlock, endBlock];\n};\n","import { ChildOf, isText, TNode, TNodeEntry } from '@udecode/slate';\nimport { Path } from 'slate';\n\n/**\n * Get the last child of a node or null if no children.\n */\nexport const getLastChild = <N extends ChildOf<R>, R extends TNode>(\n  nodeEntry: TNodeEntry<R>\n): TNodeEntry<N> | null => {\n  const [node, path] = nodeEntry;\n\n  if (isText(node)) return null;\n  if (node.children.length === 0) return null;\n\n  const children = node.children as N[];\n\n  return [children.at(-1) as N, path.concat([children.length - 1])];\n};\n\n/**\n * Get last child path. If there is no child, last index is 0.\n */\nexport const getLastChildPath = <N extends TNode>(\n  nodeEntry: TNodeEntry<N>\n): Path => {\n  const lastChild = getLastChild(nodeEntry);\n\n  if (!lastChild) return nodeEntry[1].concat([-1]);\n\n  return lastChild[1];\n};\n\n/**\n * Is the child path the last one of the parent.\n */\nexport const isLastChild = <N extends TNode>(\n  parentEntry: TNodeEntry<N>,\n  childPath: Path\n): boolean => {\n  const lastChildPath = getLastChildPath(parentEntry);\n\n  return Path.equals(lastChildPath, childPath);\n};\n","import {\n  ChildOf,\n  EElementOrText,\n  getLastNode,\n  isAncestor,\n  TEditor,\n  TNode,\n  TNodeEntry,\n  Value,\n} from '@udecode/slate';\n\nconst getLastChild = <N extends ChildOf<R>, R extends TNode>(\n  node: R,\n  level: number\n): R | N => {\n  if (!(level + 1) || !isAncestor(node)) return node;\n\n  const { children } = node;\n\n  const lastNode = children.at(-1)!;\n\n  return getLastChild(lastNode, level - 1) as N;\n};\n\n/**\n * Get the last node at a given level.\n */\nexport const getLastNodeByLevel = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  level: number\n): TNodeEntry<N> | undefined => {\n  const { children } = editor;\n\n  const lastNode = children.at(-1);\n\n  if (!lastNode) return;\n\n  const [, lastPath] = getLastNode(editor, []);\n\n  return [getLastChild(lastNode, level - 1) as N, lastPath.slice(0, level + 1)];\n};\n","import { getMarks, TEditor, Value } from '@udecode/slate';\n\n/**\n * Get selection mark value by key.\n */\nexport const getMark = <V extends Value>(editor: TEditor<V>, key: string) => {\n  if (!editor) return;\n\n  const marks = getMarks(editor);\n\n  return (marks as any)?.[key] as unknown;\n};\n","import { getNextNode, getStartPoint, TEditor, Value } from '@udecode/slate';\nimport { Path } from 'slate';\n\n/**\n * Get the start point of the next node.\n */\nexport const getNextNodeStartPoint = <V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Path\n) => {\n  const nextEntry = getNextNode(editor, {\n    at,\n  });\n  if (!nextEntry) return;\n\n  return getStartPoint(editor, nextEntry[1]);\n};\n","import { EAncestorEntry, EElementOrText, Value } from '@udecode/slate';\nimport { Path } from 'slate';\n\n/**\n * Get the next sibling nodes after a path.\n * @param ancestorEntry Ancestor of the sibling nodes\n * @param path Path of the reference node\n */\nexport const getNextSiblingNodes = <V extends Value>(\n  ancestorEntry: EAncestorEntry<V>,\n  path: Path\n): EElementOrText<V>[] => {\n  const [ancestor, ancestorPath] = ancestorEntry;\n\n  const leafIndex = path[ancestorPath.length];\n\n  const siblings: EElementOrText<V>[] = [];\n  const ancestorChildren = ancestor.children as EElementOrText<V>[];\n\n  if (leafIndex + 1 < ancestor.children.length) {\n    for (let i = leafIndex + 1; i < ancestor.children.length; i++) {\n      siblings.push(ancestorChildren[i]);\n    }\n  }\n\n  return siblings;\n};\n","import { EDescendant, TEditor, TOperation, Value } from '@udecode/slate';\n\n/**\n * Get typed editor operations.\n */\nexport const getOperations = <V extends Value>(editor: TEditor<V>) =>\n  editor.operations as TOperation<EDescendant<V>>[];\n","/* eslint-disable no-constant-condition */\nimport {\n  getEditorString,\n  getPoint,\n  getPointBefore,\n  TEditor,\n  Value,\n} from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\nimport map from 'lodash/map.js';\nimport { Location, Point } from 'slate';\n\nimport { isRangeAcrossBlocks } from './isRangeAcrossBlocks';\n\nexport interface BeforeOptions {\n  distance?: number | undefined;\n  unit?: 'character' | 'word' | 'line' | 'block' | 'offset' | undefined;\n}\n\nexport interface PointBeforeOptions extends BeforeOptions {\n  /**\n   * Lookup before the location for `matchString`.\n   */\n  matchString?: string | string[];\n\n  /**\n   * Lookup before the location until this predicate is true\n   */\n  match?: (value: {\n    beforeString: string;\n    beforePoint: Point;\n    at: Location;\n  }) => boolean;\n\n  /**\n   * If true, get the point after the matching point.\n   * If false, get the matching point.\n   */\n  afterMatch?: boolean;\n\n  /**\n   * If true, lookup until the start of the editor value.\n   * If false, lookup until the first invalid character.\n   */\n  skipInvalid?: boolean;\n}\n\n/**\n * {@link getPointBefore} with additional options.\n * TODO: support for sequence of any characters.\n */\nexport const getPointBeforeLocation = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: PointBeforeOptions\n) => {\n  if (!options || (!options.match && !options.matchString)) {\n    return getPointBefore(editor, at, options);\n  }\n\n  const unitOffset = !options.unit || options.unit === 'offset';\n\n  const matchStrings: string[] = options.matchString\n    ? castArray(options.matchString)\n    : [''];\n\n  let point: any;\n\n  matchStrings.some((matchString) => {\n    let beforeAt = at;\n    let previousBeforePoint = getPoint(editor, at, { edge: 'end' });\n\n    const stackLength = matchString.length + 1;\n    const stack: any[] = Array.from({ length: stackLength });\n\n    let count = 0;\n\n    while (true) {\n      const beforePoint = getPointBefore(editor, beforeAt, options);\n\n      // not found\n      if (!beforePoint) return;\n\n      // stop looking outside of current block\n      if (\n        isRangeAcrossBlocks(editor, {\n          at: {\n            anchor: beforePoint,\n            focus: previousBeforePoint,\n          },\n        })\n      ) {\n        return;\n      }\n\n      const beforeString = getEditorString(editor, {\n        anchor: beforePoint,\n        focus: previousBeforePoint,\n      });\n\n      let beforeStringToMatch = beforeString;\n\n      if (unitOffset && stackLength) {\n        stack.unshift({\n          point: beforePoint,\n          text: beforeString,\n        });\n        stack.pop();\n\n        beforeStringToMatch = map(stack.slice(0, -1), 'text').join('');\n      }\n\n      if (\n        matchString === beforeStringToMatch ||\n        options.match?.({ beforeString: beforeStringToMatch, beforePoint, at })\n      ) {\n        if (options.afterMatch) {\n          if (stackLength && unitOffset) {\n            point = stack.at(-1)?.point;\n            return !!point;\n          }\n          point = previousBeforePoint;\n          return true;\n        }\n        point = beforePoint;\n        return true;\n      }\n\n      previousBeforePoint = beforePoint;\n      beforeAt = beforePoint;\n\n      count += 1;\n\n      if (!options.skipInvalid && (!matchString || count >= matchString.length))\n        return;\n    }\n  });\n\n  return point;\n};\n","import { GetAboveNodeOptions, TEditor, Value } from '@udecode/slate';\nimport { Path, Range } from 'slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * Is the range (default: selection) across blocks.\n * - return undefined if block not found\n * - return boolean whether one of the block is not found, but the other is found\n * - return boolean whether block paths are unequal\n */\nexport const isRangeAcrossBlocks = <V extends Value>(\n  editor: TEditor<V>,\n  {\n    at,\n    ...options\n  }: Omit<GetAboveNodeOptions<V>, 'at'> & { at?: Range | null } = {}\n) => {\n  if (!at) at = editor.selection;\n  if (!at) return;\n\n  const [start, end] = Range.edges(at);\n  const startBlock = getBlockAbove(editor, {\n    at: start,\n    ...options,\n  });\n  const endBlock = getBlockAbove(editor, {\n    at: end,\n    ...options,\n  });\n\n  if (!startBlock && !endBlock) return;\n\n  if (!startBlock || !endBlock) return true;\n\n  return !Path.equals(startBlock[1], endBlock[1]);\n};\n","import { TEditor, Value } from '@udecode/slate';\nimport { Location, Path, Point, Range } from 'slate';\n\n/**\n * Get the point from a location (default: selection).\n * If the location is a range, get the anchor point.\n * If the location is a path, get the point at this path with offset 0.\n * If `focus` is true, get the focus point.\n */\nexport const getPointFromLocation = <V extends Value>(\n  editor: TEditor<V>,\n  {\n    at = editor.selection,\n    focus,\n  }: {\n    at?: Location | null;\n    focus?: boolean;\n  } = {}\n) => {\n  let point: Point | undefined;\n  if (Range.isRange(at)) point = focus ? at.focus : at.anchor;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = { path: at, offset: 0 };\n\n  return point;\n};\n","import {\n  getPointAfter,\n  getPointBefore,\n  getVoidNode,\n  TEditor,\n  Value,\n} from '@udecode/slate';\nimport { Path, Point } from 'slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * If the start point is inside an inline void, get the point before or after it.\n */\nexport const getPointNextToVoid = <V extends Value>(\n  editor: TEditor<V>,\n  {\n    at,\n    after,\n  }: {\n    at: Point;\n    /**\n     * Get the point after (instead of before) the void node.\n     */\n    after?: boolean;\n  }\n) => {\n  const startVoid = getVoidNode(editor, { at, mode: 'highest' });\n\n  if (startVoid) {\n    const blockAbove = getBlockAbove(editor, { at });\n\n    if (blockAbove) {\n      const nextPoint = after\n        ? getPointAfter(editor, at)\n        : getPointBefore(editor, at);\n\n      if (\n        nextPoint &&\n        blockAbove &&\n        Path.isAncestor(blockAbove[1], nextPoint.path)\n      ) {\n        at = nextPoint;\n      }\n    }\n  }\n\n  return at;\n};\n","import {\n  EElement,\n  findNode,\n  getNodeEntries,\n  getPreviousNode,\n  isBlock,\n  queryNode,\n  QueryNodeOptions,\n  TEditor,\n  TElement,\n  TNodeEntry,\n  Value,\n} from '@udecode/slate';\n\n/**\n * Find the block before a block by id.\n * If not found, find the first block by id and return [null, its previous path]\n */\nexport const getPreviousBlockById = <\n  N extends EElement<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  id: string,\n  query?: QueryNodeOptions\n): TNodeEntry<N> | undefined => {\n  const entry = findNode(editor, {\n    match: { id },\n  });\n  if (entry) {\n    const prevEntry = getPreviousNode<TElement>(editor, { at: entry[1] });\n    if (prevEntry && prevEntry[0].id && isBlock(editor, prevEntry[0])) {\n      return prevEntry as TNodeEntry<N>;\n    }\n  }\n  let found = false;\n  const _nodes = getNodeEntries<N>(editor, {\n    mode: 'highest',\n    reverse: true,\n    match: (n) => {\n      // filter nodes that are not blocks and without id.\n      if (!isBlock(editor, n) || !n.id) return false;\n\n      // find the block then take the previous one.\n      if (n.id === id) {\n        found = true;\n        return false;\n      }\n\n      return found && n.id !== id && queryNode([n, []], query);\n    },\n    at: [],\n  });\n  const nodeEntries = Array.from(_nodes);\n  if (nodeEntries.length > 0) {\n    return nodeEntries[0];\n  }\n  if (!found) return;\n\n  const _entries = getNodeEntries<TElement>(editor, {\n    mode: 'highest',\n    match: (n) => {\n      return isBlock(editor, n) && !!n.id && queryNode([n, []], query);\n    },\n    at: [],\n  });\n  const firstNodeEntry = Array.from(_entries);\n\n  if (firstNodeEntry.length > 0) {\n    const [, path] = firstNodeEntry[0];\n\n    path[path.length - 1] = path.at(-1)! - 1;\n\n    return [null, path] as any;\n  }\n};\n","import { getEndPoint, getPreviousNode, TEditor, Value } from '@udecode/slate';\nimport { Path } from 'slate';\n\n/**\n * Get the end point of the previous node.\n */\nexport const getPreviousNodeEndPoint = <V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Path\n) => {\n  const prevEntry = getPreviousNode(editor, {\n    at,\n  });\n  if (!prevEntry) return;\n\n  return getEndPoint(editor, prevEntry[1]);\n};\n","import { Path } from 'slate';\n\nexport const getPreviousPath = (path: Path): Path | undefined => {\n  if (path.length === 0) return;\n\n  const last = path.at(-1)!;\n\n  if (last <= 0) return;\n\n  return path.slice(0, -1).concat(last - 1);\n};\n","import { getNode, TEditor, Value } from '@udecode/slate';\nimport last from 'lodash/last.js';\nimport { Path } from 'slate';\n\nexport const getPreviousSiblingNode = <V extends Value = Value>(\n  editor: TEditor<V>,\n  path: Path\n) => {\n  const index = last(path)!;\n\n  if (index > 0) {\n    const previousSiblingIndex = index - 1;\n    const previousSiblingPath = path\n      .slice(0, -1)\n      .concat([previousSiblingIndex]);\n    const previousSiblingNode = getNode(editor, previousSiblingPath);\n\n    return previousSiblingNode\n      ? [previousSiblingNode, previousSiblingPath]\n      : undefined;\n  }\n};\n","import { getPoint, TEditor, Value } from '@udecode/slate';\nimport { Location, Range } from 'slate';\n\nimport {\n  getPointBeforeLocation,\n  PointBeforeOptions,\n} from './getPointBeforeLocation';\n\nexport interface RangeBeforeOptions extends PointBeforeOptions {}\n\n/**\n * Get range from {@link getPointBeforeLocation} to the end point of `at`.\n */\nexport const getRangeBefore = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: RangeBeforeOptions\n): Range | undefined => {\n  const anchor = getPointBeforeLocation(editor, at, options);\n  if (!anchor) return;\n\n  const focus = getPoint(editor, at, { edge: 'end' });\n\n  return {\n    anchor,\n    focus,\n  };\n};\n","import {\n  GetAboveNodeOptions,\n  getStartPoint,\n  TEditor,\n  Value,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\nimport { getPointFromLocation } from './getPointFromLocation';\n\n/**\n * Get the range from the start of the block above a location (default: selection) to the location.\n */\nexport const getRangeFromBlockStart = <V extends Value>(\n  editor: TEditor<V>,\n  options: Omit<GetAboveNodeOptions<V>, 'match'> = {}\n) => {\n  const path = getBlockAbove(editor, options)?.[1];\n  if (!path) return;\n\n  const start = getStartPoint(editor, path);\n\n  const focus = getPointFromLocation(editor, options);\n\n  if (!focus) return;\n\n  return { anchor: start, focus };\n};\n","import { getEditorString, TEditor, Value } from '@udecode/slate';\n\n/**\n * Get the selected text.\n * Return empty string if no selection.\n */\nexport const getSelectionText = <V extends Value>(editor: TEditor<V>) =>\n  getEditorString(editor, editor.selection);\n","import {\n  getNodeString,\n  isInline,\n  TAncestor,\n  TEditor,\n  Value,\n} from '@udecode/slate';\n\n/**\n * Is an ancestor empty (empty text and no inline children).\n */\nexport const isAncestorEmpty = <V extends Value>(\n  editor: TEditor<V>,\n  node: TAncestor\n) => !getNodeString(node) && !node.children.some((n) => isInline(editor, n));\n","import { TEditor, Value } from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\nimport { isAncestorEmpty } from './isAncestorEmpty';\n\n/**\n * Is the block above the selection empty.\n */\nexport const isBlockAboveEmpty = <V extends Value>(editor: TEditor<V>) => {\n  const block = getBlockAbove(editor)?.[0];\n  if (!block) return false;\n  return isAncestorEmpty(editor, block);\n};\n","import {\n  getParentNode,\n  isEndPoint,\n  isText,\n  TEditor,\n  Value,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\nimport { getNextSiblingNodes } from './getNextSiblingNodes';\n\n/**\n * Is there empty text after the selection.\n * If there is no leaf after the selected leaf, return {@link isEndPoint}.\n * Else, check if the next leaves are empty.\n */\nexport const isBlockTextEmptyAfterSelection = <V extends Value>(\n  editor: TEditor<V>\n) => {\n  if (!editor.selection) return false;\n\n  const blockAbove = getBlockAbove(editor);\n  if (!blockAbove) return false;\n\n  const cursor = editor.selection.focus;\n\n  const selectionParentEntry = getParentNode(editor, editor.selection);\n  if (!selectionParentEntry) return false;\n  const [, selectionParentPath] = selectionParentEntry;\n\n  if (!isEndPoint(editor, cursor, selectionParentPath)) return false;\n\n  const siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);\n\n  if (siblingNodes.length > 0) {\n    for (const siblingNode of siblingNodes) {\n      if (isText(siblingNode) && siblingNode.text) {\n        return false;\n      }\n    }\n  } else {\n    return isEndPoint(editor, cursor, blockAbove[1]);\n  }\n\n  return true;\n};\n","import { getEndPoint, isEndPoint, TEditor, Value } from '@udecode/slate';\nimport { Path } from 'slate';\n\nexport const isDocumentEnd = <V extends Value = Value>(editor: TEditor<V>) => {\n  if (editor.selection) {\n    const point = editor.selection.focus;\n    const endPoint = getEndPoint(editor, []);\n\n    return (\n      endPoint.offset === 0 &&\n      isEndPoint(editor, point, point) &&\n      Path.equals(Path.next(Path.parent(point.path)), endPoint.path)\n    );\n  }\n\n  return false;\n};\n","import { isElementEmpty, TEditor, Value } from '@udecode/slate';\n\n/**\n * Whether the editor is empty. An editor is empty if it has only one empty element.\n */\nexport const isEditorEmpty = <V extends Value>(editor: TEditor<V>) => {\n  return (\n    editor.children.length === 1 &&\n    isElementEmpty(editor, editor.children[0] as any)\n  );\n};\n","import { Path } from 'slate';\n\n/**\n * Is it the first child of the parent\n */\nexport const isFirstChild = (path: Path) => path.at(-1) === 0;\n","import { TEditor, Value } from '@udecode/slate';\nimport { isDefined } from '@udecode/utils';\n\nimport { getMark } from './getMark';\n\n/**\n * Is the mark defined in the selection.\n */\nexport const isMarkActive = <V extends Value>(\n  editor: TEditor<V>,\n  type: string\n) => {\n  return isDefined(getMark(editor, type));\n};\n","import {\n  getEditorString,\n  getPointAfter,\n  getRange,\n  TEditor,\n  Value,\n} from '@udecode/slate';\nimport { Point } from 'slate';\n\n// Starts with whitespace char or nothing\nconst AFTER_MATCH_REGEX = /^(\\s|$)/;\n\n/**\n * Is a point at the end of a word\n */\nexport const isPointAtWordEnd = <V extends Value>(\n  editor: TEditor<V>,\n  { at }: { at: Point }\n) => {\n  // Point after at\n  const after = getPointAfter(editor, at);\n\n  // From at to after\n  const afterRange = getRange(editor, at, after);\n  const afterText = getEditorString(editor, afterRange);\n\n  // Match regex on after text\n  return !!afterText.match(AFTER_MATCH_REGEX);\n};\n","import { GetAboveNodeOptions, TEditor, Value } from '@udecode/slate';\nimport { Path, Range } from 'slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * Whether the range is in the same block.\n */\nexport const isRangeInSameBlock = <V extends Value>(\n  editor: TEditor<V>,\n  {\n    at,\n    ...options\n  }: Omit<GetAboveNodeOptions<V>, 'at'> & { at?: Range | null } = {}\n) => {\n  if (!at) at = editor.selection;\n  if (!at) return;\n\n  const [start, end] = Range.edges(at);\n  const startBlock = getBlockAbove(editor, {\n    at: start,\n    ...options,\n  });\n  const endBlock = getBlockAbove(editor, {\n    at: end,\n    ...options,\n  });\n\n  if (!startBlock || !endBlock) return;\n\n  return Path.equals(startBlock[1], endBlock[1]);\n};\n","import { Path, Range } from 'slate';\n\n/**\n * Is the range in the same single text path.\n */\nexport const isRangeInSingleText = (at: Range) => {\n  const [start, end] = Range.edges(at);\n  return Path.equals(start.path, end.path);\n};\n","import {\n  GetAboveNodeOptions,\n  isEndPoint,\n  TEditor,\n  Value,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * Is the selection focus at the end of its parent block.\n */\nexport const isSelectionAtBlockEnd = <V extends Value>(\n  editor: TEditor<V>,\n  options?: GetAboveNodeOptions<V>\n): boolean => {\n  const path = getBlockAbove(editor, options)?.[1];\n\n  return !!path && isEndPoint(editor, editor.selection?.focus, path);\n};\n","import {\n  GetAboveNodeOptions,\n  isExpanded,\n  isStartPoint,\n  TEditor,\n  Value,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * Is the selection anchor or focus at the start of its parent block.\n *\n * Supports the same options provided by {@link getBlockAbove}.\n */\nexport const isSelectionAtBlockStart = <V extends Value>(\n  editor: TEditor<V>,\n  options?: GetAboveNodeOptions<V>\n) => {\n  const { selection } = editor;\n  if (!selection) return false;\n\n  const path = getBlockAbove(editor, options)?.[1];\n  if (!path) return false;\n\n  return (\n    isStartPoint(editor, selection.focus, path) ||\n    (isExpanded(editor.selection) &&\n      isStartPoint(editor, selection.anchor, path))\n  );\n};\n","import { isExpanded, TEditor, Value } from '@udecode/slate';\n\n/**\n * Is the selection expanded.\n */\nexport const isSelectionExpanded = <V extends Value>(editor: TEditor<V>) =>\n  isExpanded(editor.selection);\n","import { getNode, isText, TEditor, Value } from '@udecode/slate';\nimport { Path } from 'slate';\n\nexport const isTextByPath = <V extends Value>(\n  editor: TEditor<V>,\n  path: Path\n) => {\n  const node = getNode(editor, path);\n\n  return isText(node);\n};\n","import {\n  getEditorString,\n  getPointBefore,\n  getRange,\n  TEditor,\n  Value,\n} from '@udecode/slate';\nimport { escapeRegExp } from '@udecode/utils';\nimport { Point } from 'slate';\n\n/**\n * Is the word at the point after a trigger (punctuation character)\n * https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/utils/string.ts#L6\n */\nexport const isWordAfterTrigger = <V extends Value>(\n  editor: TEditor<V>,\n  { at, trigger }: { at: Point; trigger: string }\n) => {\n  // Point at the start of previous word (excluding punctuation)\n  const wordBefore = getPointBefore(editor, at, { unit: 'word' });\n\n  // Point before wordBefore\n  const before = wordBefore && getPointBefore(editor, wordBefore);\n\n  // Range from before to start\n  const beforeRange = before && getRange(editor, before, at);\n\n  // Before text\n  const beforeText = getEditorString(editor, beforeRange);\n\n  // Starts with char and ends with word characters\n  const escapedTrigger = escapeRegExp(trigger);\n\n  const beforeRegex = new RegExp(\n    `^${escapedTrigger}([\\\\w|À-ÖØ-öø-ÿ|а-яА-ЯёЁ]+)$`\n  );\n\n  // Match regex on before text\n  const match = beforeText ? beforeText.match(beforeRegex) : null;\n\n  return {\n    range: beforeRange,\n    match,\n  };\n};\n","import { QueryEditorOptions, someNode, TEditor, Value } from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\n\nimport { isSelectionAtBlockEnd } from './isSelectionAtBlockEnd';\nimport { isSelectionAtBlockStart } from './isSelectionAtBlockStart';\n\n/**\n * Query the editor state.\n */\nexport const queryEditor = <\n  V extends Value = Value,\n  E extends TEditor<V> = TEditor<V>,\n>(\n  editor: E,\n  {\n    filter,\n    selectionAtBlockStart,\n    selectionAtBlockEnd,\n    allow,\n    exclude,\n    at = editor.selection || [],\n  }: QueryEditorOptions<V, E> = {}\n) => {\n  if (\n    (filter && !filter(editor)) ||\n    (selectionAtBlockStart && !isSelectionAtBlockStart(editor)) ||\n    (selectionAtBlockEnd && !isSelectionAtBlockEnd(editor))\n  ) {\n    return false;\n  }\n\n  const allows = castArray(allow);\n  if (allows.length > 0 && !someNode(editor, { at, match: { type: allows } })) {\n    return false;\n  }\n\n  const excludes = castArray(exclude);\n  if (\n    excludes.length > 0 &&\n    someNode(editor, { at, match: { type: excludes } })\n  ) {\n    return false;\n  }\n\n  return true;\n};\n","import {\n  EElement,\n  insertNodes,\n  InsertNodesOptions,\n  TEditor,\n  TElement,\n  Value,\n} from '@udecode/slate';\n\nexport const insertElements = <V extends Value>(\n  editor: TEditor<V>,\n  nodes: TElement | TElement[],\n  options?: InsertNodesOptions<V>\n) => {\n  insertNodes(editor, nodes as EElement<V> | EElement<V>[], options);\n};\n","import {\n  getQueryOptions,\n  InsertNodesOptions,\n  TEditor,\n  Value,\n} from '@udecode/slate';\n\nimport { insertElements } from './insertElements';\n\nexport const insertEmptyElement = <V extends Value>(\n  editor: TEditor<V>,\n  type: string,\n  options?: InsertNodesOptions<V>\n) => {\n  insertElements(\n    editor,\n    {\n      type,\n      children: [{ text: '' }],\n    },\n    getQueryOptions(editor, options)\n  );\n};\n","import {\n  ENodeEntry,\n  getNode,\n  isBlock,\n  moveNodes,\n  TEditor,\n  TElement,\n  Value,\n} from '@udecode/slate';\nimport { Path } from 'slate';\n\nexport interface MoveChildrenOptions<V extends Value = Value> {\n  /**\n   * Parent node of the children to move.\n   */\n  at: ENodeEntry<V> | Path;\n\n  /**\n   * Path where to move the children.\n   */\n  to: Path;\n\n  /**\n   * Start index of the children to move.\n   * Example: 1 means children[0] will not be moved.\n   */\n  fromStartIndex?: number;\n\n  /**\n   * Condition for the child to be moved\n   */\n  match?(entry: ENodeEntry<V>): boolean;\n}\n\n/**\n * Move the children of a node to a path.\n * Returns the number of children moved.\n */\nexport const moveChildren = <V extends Value>(\n  editor: TEditor<V>,\n  { at, to, match, fromStartIndex = 0 }: MoveChildrenOptions<V>\n) => {\n  let moved = 0;\n  const parentPath = Path.isPath(at) ? at : at[1];\n  const parentNode = Path.isPath(at) ? getNode(editor, parentPath) : at[0];\n\n  if (!parentNode) return moved;\n  if (!isBlock(editor, parentNode)) return moved;\n\n  for (\n    let i = (parentNode.children as TElement[]).length - 1;\n    i >= fromStartIndex;\n    i--\n  ) {\n    const childPath = [...parentPath, i];\n    const childNode = getNode(editor, childPath);\n\n    if (!match || (childNode && match([childNode, childPath]))) {\n      moveNodes(editor, { at: childPath, to });\n      moved++;\n    }\n  }\n\n  return moved;\n};\n","import {\n  getMarks,\n  isText,\n  SetNodesOptions,\n  TEditor,\n  unsetNodes,\n  Value,\n} from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\nimport { Range } from 'slate';\n\nexport interface RemoveMarkOptions<V extends Value = Value>\n  extends Omit<SetNodesOptions<V>, 'match' | 'split'> {\n  /**\n   * Mark or the array of marks that will be removed\n   */\n  key: string | string[];\n\n  /**\n   * When location is not a Range,\n   * setting this to false can prevent the onChange event of the editor to fire\n   * @default true\n   */\n  shouldChange?: boolean;\n\n  /**\n   * Range where the mark(s) will be removed\n   */\n  at?: Range;\n}\n\n/**\n * Remove mark and trigger `onChange` if collapsed selection.\n */\nexport const removeMark = <V extends Value>(\n  editor: TEditor<V>,\n  { key, at, shouldChange = true, ...rest }: RemoveMarkOptions<V>\n) => {\n  const selection = at ?? editor.selection;\n  key = castArray(key);\n\n  if (selection) {\n    if (Range.isRange(selection) && Range.isExpanded(selection)) {\n      unsetNodes(editor, key as any as string, {\n        at: selection,\n        match: isText,\n        split: true,\n        ...rest,\n      });\n    } else if (editor.selection) {\n      const marks: any = getMarks(editor) ?? {};\n      key.forEach((k) => {\n        delete marks[k];\n      });\n      editor.marks = marks;\n      shouldChange && editor.onChange();\n    }\n  }\n};\n","import { getMarks, removeEditorMark, TEditor, Value } from '@udecode/slate';\n\n/**\n * Remove selection marks.\n */\nexport const removeSelectionMark = <V extends Value = Value>(\n  editor: TEditor<V>\n) => {\n  const marks = getMarks(editor);\n  if (!marks) return;\n\n  // remove all marks\n  Object.keys(marks).forEach((key) => {\n    removeEditorMark(editor, key);\n  });\n};\n","import {\n  EElementOrText,\n  insertNodes,\n  removeNodes,\n  TEditor,\n  Value,\n  withoutNormalizing,\n} from '@udecode/slate';\n\nimport { ReplaceNodeChildrenOptions } from './replaceNodeChildren';\n\nexport const replaceNode = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  { at, nodes, insertOptions, removeOptions }: ReplaceNodeChildrenOptions<N, V>\n) => {\n  withoutNormalizing(editor, () => {\n    removeNodes(editor, { ...insertOptions, at });\n\n    insertNodes(editor, nodes, {\n      ...insertOptions,\n      at,\n    });\n  });\n};\n","import {\n  EElementOrText,\n  insertNodes,\n  InsertNodesOptions,\n  RemoveNodesOptions,\n  TEditor,\n  Value,\n  withoutNormalizing,\n} from '@udecode/slate';\nimport { Path } from 'slate';\n\nimport { removeNodeChildren } from './removeNodeChildren';\n\nexport interface ReplaceNodeChildrenOptions<\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n> {\n  at: Path;\n  nodes: N | N[];\n  removeOptions?: Omit<RemoveNodesOptions<V>, 'at'>;\n  insertOptions?: Omit<InsertNodesOptions<V>, 'at'>;\n}\n\n/**\n * Replace node children: remove then insert.\n */\nexport const replaceNodeChildren = <\n  N extends EElementOrText<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  { at, nodes, insertOptions, removeOptions }: ReplaceNodeChildrenOptions<N, V>\n) => {\n  withoutNormalizing(editor, () => {\n    removeNodeChildren(editor, at, removeOptions);\n\n    insertNodes(editor, nodes, {\n      ...insertOptions,\n      at: at.concat([0]),\n    });\n  });\n};\n","import {\n  getNodeChildren,\n  removeNodes,\n  RemoveNodesOptions,\n  TEditor,\n  Value,\n  withoutNormalizing,\n} from '@udecode/slate';\nimport { Path } from 'slate';\n\n/**\n * Remove node children.\n */\nexport const removeNodeChildren = <V extends Value = Value>(\n  editor: TEditor<V>,\n  path: Path,\n  options?: Omit<RemoveNodesOptions<V>, 'at'>\n) => {\n  withoutNormalizing(editor, () => {\n    for (const [, childPath] of getNodeChildren(editor, path, {\n      reverse: true,\n    })) {\n      removeNodes(editor, { ...options, at: childPath });\n    }\n  });\n};\n","import { getEndPoint, select, TEditor, Value } from '@udecode/slate';\nimport { Path } from 'slate';\n\nimport { getBlockAbove } from '../queries';\n\n/**\n * Select the end point of the block above the selection.\n */\nexport const selectEndOfBlockAboveSelection = <V extends Value>(\n  editor: TEditor<V>\n) => {\n  const path = getBlockAbove(editor)?.[1];\n\n  path && select(editor, getEndPoint(editor, path as Path));\n};\n","import { EMarks, TEditor, Value, withoutNormalizing } from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\n\nimport { removeMark } from './removeMark';\n\n/**\n * Set marks to selected text.\n */\nexport const setMarks = <V extends Value>(\n  editor: TEditor<V>,\n  marks: EMarks<V>,\n  clear: string | string[] = []\n) => {\n  if (!editor.selection) return;\n\n  withoutNormalizing(editor, () => {\n    const clears = castArray<string>(clear);\n    removeMark(editor, { key: clears });\n    removeMark(editor, { key: Object.keys(marks) });\n\n    Object.keys(marks).forEach((key) => {\n      editor.addMark(key, (marks as any)[key]);\n    });\n  });\n};\n","import { TEditor, Value, withoutNormalizing } from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\n\nimport { isMarkActive } from '../queries';\nimport { removeMark } from './removeMark';\n\nexport interface ToggleMarkOptions {\n  clear?: string | string[];\n  key: string;\n}\n\n/**\n * Add/remove marks in the selection.\n * @param editor\n * @param key mark to toggle\n * @param clear marks to clear when adding mark\n */\nexport const toggleMark = <V extends Value = Value>(\n  editor: TEditor<V>,\n  { key, clear }: ToggleMarkOptions\n) => {\n  if (!editor.selection) return;\n\n  withoutNormalizing(editor, () => {\n    const isActive = isMarkActive(editor, key);\n\n    if (isActive) {\n      removeMark(editor, { key });\n      return;\n    }\n\n    if (clear) {\n      const clears = castArray<string>(clear);\n      removeMark(editor, { key: clears });\n    }\n\n    editor.addMark(key, true);\n  });\n};\n","import {\n  someNode,\n  TEditor,\n  TElement,\n  unwrapNodes,\n  Value,\n  wrapNodes,\n} from '@udecode/slate';\n\n/**\n * Unwrap if the node type is in selection.\n * Wrap otherwise.\n */\nexport const toggleWrapNodes = <V extends Value>(\n  editor: TEditor<V>,\n  type: string\n) => {\n  if (someNode(editor, { match: { type } })) {\n    unwrapNodes(editor, { match: { type } });\n  } else {\n    wrapNodes<TElement>(editor, {\n      type,\n      children: [],\n    });\n  }\n};\n","import {\n  EElement,\n  getNode,\n  TEditor,\n  TElement,\n  Value,\n  withoutNormalizing,\n  wrapNodes,\n  WrapNodesOptions,\n} from '@udecode/slate';\nimport { Modify } from '@udecode/utils';\nimport { Path } from 'slate';\n\nimport { moveChildren } from './moveChildren';\n\n/**\n * Wrap node children into a single element:\n * - wraps the first child node into the element\n * - move the other child nodes next to the element children.\n */\nexport const wrapNodeChildren = <\n  N extends EElement<V>,\n  V extends Value = Value,\n>(\n  editor: TEditor<V>,\n  element: N,\n  options: Modify<WrapNodesOptions<V>, { at: Path }>\n) => {\n  const path = options?.at;\n  const node = getNode<TElement>(editor, path);\n  if (!node?.children) return;\n\n  withoutNormalizing(editor, () => {\n    const firstChildPath = path.concat([0]);\n\n    wrapNodes(editor, element, {\n      ...options,\n      at: firstChildPath,\n    });\n\n    if (node.children.length < 2) return;\n\n    moveChildren(editor, {\n      at: path,\n      to: firstChildPath.concat([1]),\n      fromStartIndex: 1,\n    });\n  });\n};\n","import { TDescendant } from '@udecode/slate';\n\nexport const createDocumentNode = (\n  type = 'p',\n  text = '',\n  remaining: TDescendant[] = []\n): TDescendant[] => [\n  {\n    children: [\n      {\n        type,\n        children: [{ text }],\n      },\n      ...remaining,\n    ],\n  } as any,\n];\n","import { TElement } from '@udecode/slate';\n\nexport const createNode = (type = 'p', text = ''): TElement => ({\n  type,\n  children: [{ text }],\n});\n"],"mappings":"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","names":["last","Path","isAncestor","getLastChild","Path","Range","Range","Path","Path","Range","getPointBefore","Path","getPointBefore","Path","getPreviousNode","last","getPoint","getPoint","getStartPoint","getStartPoint","getEditorString","isText","isText","getEndPoint","isEndPoint","Path","getEditorString","getPointAfter","Path","Range","Range","Path","Path","Range","isEndPoint","isEndPoint","isExpanded","getNode","isText","getEditorString","getPointBefore","getRange","match","castArray","castArray","getNode","isBlock","Path","match","getMarks","isText","castArray","Range","_a","castArray","Range","isText","getMarks","getMarks","insertNodes","insertNodes","insertNodes","withoutNormalizing","removeNodes","withoutNormalizing","withoutNormalizing","removeNodes","withoutNormalizing","insertNodes","getEndPoint","getEndPoint","withoutNormalizing","castArray","withoutNormalizing","castArray","withoutNormalizing","castArray","withoutNormalizing","castArray","someNode","getNode","withoutNormalizing","wrapNodes","getNode","withoutNormalizing","wrapNodes"]}