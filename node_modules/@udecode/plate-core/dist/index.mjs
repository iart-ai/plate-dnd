var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/components/DefaultLeaf.tsx
import React from "react";
function DefaultLeaf(_a) {
  var _b = _a, {
    attributes,
    children,
    text,
    leaf,
    editor,
    nodeProps
  } = _b, props = __objRest(_b, [
    "attributes",
    "children",
    "text",
    "leaf",
    "editor",
    "nodeProps"
  ]);
  return /* @__PURE__ */ React.createElement("span", __spreadValues(__spreadValues({}, attributes), props), children);
}

// src/components/EditorMethodsEffect.ts
import React13 from "react";

// src/libs/jotai.ts
import { createAtomStore } from "jotai-x";
import { atom } from "jotai";

// src/libs/nanoid.ts
import { nanoid } from "nanoid";

// src/libs/react-hotkeys-hook.ts
import { isHotkeyPressed, useHotkeys } from "react-hotkeys-hook";

// src/libs/zustand.ts
import { createZustandStore } from "zustand-x";

// src/stores/element/useElementStore.ts
var SCOPE_ELEMENT = "element";
var initialState = {
  element: null
};
var { useElementStore, ElementProvider } = createAtomStore(
  initialState,
  { name: "element" }
);

// src/stores/element/useElement.ts
var useElement = (pluginKey = SCOPE_ELEMENT) => {
  const value = useElementStore(pluginKey).get.element();
  if (!value) {
    console.warn(
      `The \`useElement(pluginKey)\` hook must be used inside the node component's context`
    );
    return {};
  }
  return value;
};

// src/stores/event-editor/eventEditorStore.ts
var eventEditorStore = createZustandStore("event-editor")({
  blur: null,
  focus: null,
  last: null
});
var eventEditorActions = eventEditorStore.set;
var eventEditorSelectors = eventEditorStore.get;
var useEventEditorSelectors = eventEditorStore.use;

// src/stores/plate/createPlateStore.ts
import React8 from "react";
import { atom as atom3, createStore } from "jotai";

// src/utils/applyDeepToNodes.ts
import {
  isAncestor,
  queryNode
} from "@udecode/slate";
var applyDeepToNodes = ({
  node,
  path = [],
  source,
  apply,
  query
}) => {
  const entry = [node, path];
  if (queryNode(entry, query)) {
    if (source instanceof Function) {
      apply(node, source());
    } else {
      apply(node, source);
    }
  }
  if (!isAncestor(node))
    return;
  node.children.forEach((child, index) => {
    applyDeepToNodes({
      node: child,
      path: path.concat([index]),
      source,
      apply,
      query
    });
  });
};

// src/utils/createPlateEditor.ts
import { createTEditor, normalizeEditor } from "@udecode/slate";

// src/transforms/resetEditor.ts
import { focusEditorEdge, isEditorFocused } from "@udecode/slate-react";

// src/transforms/resetEditorChildren.ts
import {
  replaceNodeChildren
} from "@udecode/slate-utils";
var resetEditorChildren = (editor, options) => {
  replaceNodeChildren(editor, __spreadValues({
    at: [],
    nodes: editor.childrenFactory()
  }, options));
};

// src/transforms/resetEditor.ts
var resetEditor = (editor) => {
  const isFocused = isEditorFocused(editor);
  resetEditorChildren(editor);
  editor.history.undos = [];
  editor.history.redos = [];
  editor.operations = [];
  if (isFocused) {
    focusEditorEdge(editor, { edge: "start" });
  }
};

// src/transforms/toggleNodeType.ts
import {
  setElements,
  someNode
} from "@udecode/slate";

// src/constants/ELEMENT_DEFAULT.ts
var ELEMENT_DEFAULT = "p";

// src/utils/getPluginsByKey.ts
var getPluginsByKey = (editor) => {
  var _a;
  return (_a = editor == null ? void 0 : editor.pluginsByKey) != null ? _a : {};
};

// src/utils/getPlugin.ts
var getPlugin = (editor, key) => {
  var _a;
  return (_a = getPluginsByKey(editor)[key]) != null ? _a : { key };
};

// src/utils/getPluginType.ts
var getPluginType = (editor, key) => {
  var _a, _b;
  return (_b = (_a = getPlugin(editor, key).type) != null ? _a : key) != null ? _b : "";
};

// src/transforms/toggleNodeType.ts
var toggleNodeType = (editor, options, editorNodesOptions) => {
  const { activeType, inactiveType = getPluginType(editor, ELEMENT_DEFAULT) } = options;
  if (!activeType || !editor.selection)
    return;
  const isActive = someNode(editor, __spreadProps(__spreadValues({}, editorNodesOptions), {
    match: {
      type: activeType
    }
  }));
  if (isActive && activeType === inactiveType)
    return;
  setElements(editor, {
    type: isActive ? inactiveType : activeType
  });
};

// src/utils/setPlatePlugins.ts
import { isDefined as isDefined2 } from "@udecode/utils";

// src/utils/overridePluginsByKey.ts
import defaultsDeep from "lodash/defaultsDeep.js";
var overridePluginsByKey = (plugin, overrideByKey = {}, nested = false) => {
  var _b;
  if (overrideByKey[plugin.key]) {
    const _a = overrideByKey[plugin.key], {
      plugins: pluginOverridesPlugins,
      then: pluginOverridesThen
    } = _a, pluginOverrides = __objRest(_a, [
      "plugins",
      "then"
    ]);
    plugin = defaultsDeep(pluginOverrides, plugin);
    if (!nested) {
      pluginOverridesPlugins == null ? void 0 : pluginOverridesPlugins.forEach((pOverrides) => {
        if (!plugin.plugins)
          plugin.plugins = [];
        const found = plugin.plugins.find((p) => p.key === pOverrides.key);
        if (!found)
          plugin.plugins.push(pOverrides);
      });
    }
  }
  if (plugin.plugins) {
    plugin.plugins = plugin.plugins.map(
      (p) => overridePluginsByKey(p, overrideByKey, true)
    );
  }
  const { then } = plugin;
  if (then) {
    if (plugin._thenReplaced === void 0) {
      plugin._thenReplaced = 0;
    }
    if (plugin._thenReplaced < 3) {
      plugin.then = (editor, p) => {
        const pluginThen = __spreadValues({ key: plugin.key }, then(editor, p));
        return defaultsDeep(
          overridePluginsByKey(pluginThen, overrideByKey),
          pluginThen
        );
      };
      plugin._thenReplaced++;
    }
  } else if ((_b = overrideByKey[plugin.key]) == null ? void 0 : _b.then) {
    plugin.then = overrideByKey[plugin.key].then;
  }
  return plugin;
};

// src/utils/createPluginFactory.ts
var createPluginFactory = (defaultPlugin) => (override, overrideByKey = {}) => {
  overrideByKey[defaultPlugin.key] = override;
  return overridePluginsByKey(
    __spreadValues({}, defaultPlugin),
    overrideByKey
  );
};

// src/plugins/createDeserializeAstPlugin.ts
var KEY_DESERIALIZE_AST = "deserializeAst";
var createDeserializeAstPlugin = createPluginFactory({
  key: KEY_DESERIALIZE_AST,
  editor: {
    insertData: {
      format: "application/x-slate-fragment",
      getFragment: ({ data }) => {
        const decoded = decodeURIComponent(window.atob(data));
        let parsed;
        try {
          parsed = JSON.parse(decoded);
        } catch (error) {
        }
        return parsed;
      }
    }
  }
});

// src/plugins/createEditorProtocolPlugin.ts
import {
  getAboveNode,
  getMarks,
  isExpanded,
  isStartPoint,
  removeEditorMark
} from "@udecode/slate";
var getBlockAbove = (editor, options = {}) => getAboveNode(editor, __spreadProps(__spreadValues({}, options), {
  block: true
}));
var isSelectionAtBlockStart = (editor, options) => {
  var _a;
  const { selection } = editor;
  if (!selection)
    return false;
  const path = (_a = getBlockAbove(editor, options)) == null ? void 0 : _a[1];
  if (!path)
    return false;
  return isStartPoint(editor, selection.focus, path) || isExpanded(editor.selection) && isStartPoint(editor, selection.anchor, path);
};
var removeSelectionMark = (editor) => {
  const marks = getMarks(editor);
  if (!marks)
    return;
  Object.keys(marks).forEach((key) => {
    removeEditorMark(editor, key);
  });
};
var KEY_EDITOR_PROTOCOL = "editorProtocol";
var withEditorProtocol = (editor) => {
  const { deleteBackward, deleteForward, deleteFragment } = editor;
  const resetMarks = () => {
    if (isSelectionAtBlockStart(editor)) {
      removeSelectionMark(editor);
    }
  };
  editor.deleteBackward = (unit) => {
    deleteBackward(unit);
    resetMarks();
  };
  editor.deleteForward = (unit) => {
    deleteForward(unit);
    resetMarks();
  };
  editor.deleteFragment = (direction) => {
    deleteFragment(direction);
    resetMarks();
  };
  return editor;
};
var createEditorProtocolPlugin = createPluginFactory({
  key: KEY_EDITOR_PROTOCOL,
  withOverrides: withEditorProtocol
});

// src/plugins/createEventEditorPlugin.ts
var KEY_EVENT_EDITOR = "event-editor";
var createEventEditorPlugin = createPluginFactory({
  key: KEY_EVENT_EDITOR,
  handlers: {
    onFocus: (editor) => () => {
      eventEditorActions.focus(editor.id);
    },
    onBlur: (editor) => () => {
      const focus = eventEditorSelectors.focus();
      if (focus === editor.id) {
        eventEditorActions.focus(null);
      }
      eventEditorActions.blur(editor.id);
    }
  }
});

// src/plugins/createHistoryPlugin.ts
import { withHistory } from "slate-history";
var withTHistory = (editor) => withHistory(editor);
var createHistoryPlugin = createPluginFactory({
  key: "history",
  withOverrides: withTHistory
});

// src/plugins/createInlineVoidPlugin.ts
var KEY_INLINE_VOID = "inline-void";
var withInlineVoid = (editor) => {
  const { isInline, isVoid, markableVoid } = editor;
  const voidTypes = [];
  const inlineTypes = [];
  const markableVoidTypes = [];
  editor.plugins.forEach((plugin) => {
    if (plugin.isInline) {
      inlineTypes.push(plugin.type);
    }
    if (plugin.isVoid) {
      voidTypes.push(plugin.type);
    }
    if (plugin.isMarkableVoid) {
      markableVoidTypes.push(plugin.type);
    }
  });
  editor.isInline = (element) => {
    return inlineTypes.includes(element.type) ? true : isInline(element);
  };
  editor.isVoid = (element) => {
    return voidTypes.includes(element.type) ? true : isVoid(element);
  };
  editor.markableVoid = (element) => {
    return markableVoidTypes.includes(element.type) ? true : markableVoid(element);
  };
  return editor;
};
var createInlineVoidPlugin = createPluginFactory({
  key: KEY_INLINE_VOID,
  withOverrides: withInlineVoid
});

// src/utils/getInjectedPlugins.ts
var getInjectedPlugins = (editor, plugin) => {
  const injectedPlugins = [];
  [...editor.plugins].reverse().forEach((p) => {
    var _a;
    const injectedPlugin = (_a = p.inject.pluginsByKey) == null ? void 0 : _a[plugin.key];
    if (injectedPlugin)
      injectedPlugins.push(injectedPlugin);
  });
  return [plugin, ...injectedPlugins];
};

// src/utils/pipeInsertDataQuery.ts
var pipeInsertDataQuery = (plugins, { data, dataTransfer }) => plugins.every((p) => {
  var _a, _b;
  const query = (_b = (_a = p.editor) == null ? void 0 : _a.insertData) == null ? void 0 : _b.query;
  return !query || query({
    data,
    dataTransfer
  });
});

// src/utils/pipeInsertFragment.ts
import { withoutNormalizing } from "@udecode/slate";
var pipeInsertFragment = (editor, injectedPlugins, _a) => {
  var _b = _a, {
    fragment
  } = _b, options = __objRest(_b, [
    "fragment"
  ]);
  withoutNormalizing(editor, () => {
    injectedPlugins.some((p) => {
      var _a2, _b2, _c;
      return ((_c = (_b2 = (_a2 = p.editor) == null ? void 0 : _a2.insertData) == null ? void 0 : _b2.preInsert) == null ? void 0 : _c.call(_b2, fragment, options)) === true;
    });
    editor.insertFragment(fragment);
  });
};

// src/utils/pipeTransformData.ts
var pipeTransformData = (plugins, { data, dataTransfer }) => {
  plugins.forEach((p) => {
    var _a, _b;
    const transformData = (_b = (_a = p.editor) == null ? void 0 : _a.insertData) == null ? void 0 : _b.transformData;
    if (!transformData)
      return;
    data = transformData(data, { dataTransfer });
  });
  return data;
};

// src/utils/pipeTransformFragment.ts
var pipeTransformFragment = (plugins, _a) => {
  var _b = _a, {
    fragment
  } = _b, options = __objRest(_b, [
    "fragment"
  ]);
  plugins.forEach((p) => {
    var _a2, _b2;
    const transformFragment = (_b2 = (_a2 = p.editor) == null ? void 0 : _a2.insertData) == null ? void 0 : _b2.transformFragment;
    if (!transformFragment)
      return;
    fragment = transformFragment(fragment, options);
  });
  return fragment;
};

// src/plugins/createInsertDataPlugin.ts
var withInsertData = (editor) => {
  const { insertData } = editor;
  editor.insertData = (dataTransfer) => {
    const inserted = [...editor.plugins].reverse().some((plugin) => {
      const insertDataOptions = plugin.editor.insertData;
      if (!insertDataOptions)
        return false;
      const injectedPlugins = getInjectedPlugins(editor, plugin);
      const { format, getFragment } = insertDataOptions;
      if (!format)
        return false;
      let data = dataTransfer.getData(format);
      if (!data)
        return;
      if (!pipeInsertDataQuery(injectedPlugins, {
        data,
        dataTransfer
      })) {
        return false;
      }
      data = pipeTransformData(injectedPlugins, {
        data,
        dataTransfer
      });
      let fragment = getFragment == null ? void 0 : getFragment({
        data,
        dataTransfer
      });
      if (!(fragment == null ? void 0 : fragment.length))
        return false;
      fragment = pipeTransformFragment(injectedPlugins, {
        fragment,
        data,
        dataTransfer
      });
      if (fragment.length === 0)
        return false;
      pipeInsertFragment(editor, injectedPlugins, {
        fragment,
        data,
        dataTransfer
      });
      return true;
    });
    if (inserted)
      return;
    insertData(dataTransfer);
  };
  return editor;
};
var KEY_INSERT_DATA = "insertData";
var createInsertDataPlugin = createPluginFactory({
  key: KEY_INSERT_DATA,
  withOverrides: withInsertData
});

// src/plugins/createLengthPlugin.ts
import { getEditorString, withoutNormalizing as withoutNormalizing2 } from "@udecode/slate";
var KEY_LENGTH = "length";
var withLength = (editor, { options }) => {
  const { apply } = editor;
  editor.apply = (operation) => {
    withoutNormalizing2(editor, () => {
      apply(operation);
      if (options.maxLength) {
        const length = getEditorString(editor, []).length;
        if (length > options.maxLength) {
          const overflowLength = length - options.maxLength;
          editor.delete({
            unit: "character",
            distance: overflowLength,
            reverse: true
          });
        }
      }
    });
  };
  return editor;
};
var createLengthPlugin = createPluginFactory({
  key: KEY_LENGTH,
  withOverrides: withLength
});

// src/plugins/createNodeFactoryPlugin.ts
var KEY_NODE_FACTORY = "nodeFactory";
var createNodeFactoryPlugin = createPluginFactory({
  key: KEY_NODE_FACTORY,
  withOverrides: (editor) => {
    editor.blockFactory = (node) => __spreadValues({
      type: getPluginType(editor, ELEMENT_DEFAULT),
      children: [{ text: "" }]
    }, node);
    editor.childrenFactory = () => [editor.blockFactory()];
    return editor;
  }
});

// src/plugins/createPrevSelectionPlugin.ts
var KEY_PREV_SELECTION = "prevSelection";
var createPrevSelectionPlugin = createPluginFactory({
  key: KEY_PREV_SELECTION,
  handlers: {
    onKeyDown: (editor) => (e) => {
      e.persist();
      editor.currentKeyboardEvent = e;
    }
  },
  withOverrides: (editor) => {
    const { apply } = editor;
    editor.apply = (operation) => {
      if (operation.type === "set_selection") {
        const { properties } = operation;
        editor.prevSelection = properties;
        apply(operation);
        editor.currentKeyboardEvent = null;
        return;
      }
      apply(operation);
    };
    return editor;
  }
});

// src/plugins/withTReact.ts
import { withReact } from "slate-react";
var withTReact = (editor) => withReact(editor);

// src/plugins/createReactPlugin.ts
var createReactPlugin = createPluginFactory({
  key: "react",
  withOverrides: withTReact
});

// src/plugins/html-deserializer/constants.ts
var CARRIAGE_RETURN = "\r";
var LINE_FEED = "\n";
var NO_BREAK_SPACE = "\xA0";
var SPACE = " ";
var TAB = "	";
var ZERO_WIDTH_SPACE = "\u200B";

// src/utils/normalizeDescendantsToDocumentFragment.ts
import {
  isElement,
  isText
} from "@udecode/slate";
var isInlineNode = (editor) => (node) => isText(node) || isElement(node) && editor.isInline(node);
var makeBlockLazy = (type) => () => ({
  type,
  children: []
});
var hasDifferentChildNodes = (descendants, isInline) => {
  return descendants.some((descendant, index, arr) => {
    const prevDescendant = arr[index - 1];
    if (index !== 0) {
      return isInline(descendant) !== isInline(prevDescendant);
    }
    return false;
  });
};
var normalizeDifferentNodeTypes = (descendants, isInline, makeDefaultBlock) => {
  const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline);
  const { fragment } = descendants.reduce(
    (memo, node) => {
      if (hasDifferentNodes && isInline(node)) {
        let block = memo.precedingBlock;
        if (!block) {
          block = makeDefaultBlock();
          memo.precedingBlock = block;
          memo.fragment.push(block);
        }
        block.children.push(node);
      } else {
        memo.fragment.push(node);
        memo.precedingBlock = null;
      }
      return memo;
    },
    {
      fragment: [],
      precedingBlock: null
    }
  );
  return fragment;
};
var normalizeEmptyChildren = (descendants) => {
  if (descendants.length === 0) {
    return [{ text: "" }];
  }
  return descendants;
};
var normalize = (descendants, isInline, makeDefaultBlock) => {
  descendants = normalizeEmptyChildren(descendants);
  descendants = normalizeDifferentNodeTypes(
    descendants,
    isInline,
    makeDefaultBlock
  );
  descendants = descendants.map((node) => {
    if (isElement(node)) {
      return __spreadProps(__spreadValues({}, node), {
        children: normalize(node.children, isInline, makeDefaultBlock)
      });
    }
    return node;
  });
  return descendants;
};
var normalizeDescendantsToDocumentFragment = (editor, { descendants }) => {
  const isInline = isInlineNode(editor);
  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);
  const makeDefaultBlock = makeBlockLazy(defaultType);
  return normalize(descendants, isInline, makeDefaultBlock);
};

// src/plugins/html-deserializer/utils/collapse-white-space/collapseString.ts
var collapseString = (text, {
  trimStart = "collapse",
  trimEnd = "collapse",
  shouldCollapseWhiteSpace = true,
  whiteSpaceIncludesNewlines = true
} = {}) => {
  if (trimStart === "all") {
    text = text.replace(/^\s+/, "");
  }
  if (trimEnd === "single-newline") {
    text = text.replace(/\n$/, "");
  }
  if (shouldCollapseWhiteSpace) {
    if (whiteSpaceIncludesNewlines) {
      text = text.replaceAll(/\s+/g, " ");
    } else {
      text = text.replaceAll(/[^\S\n\r]+/g, " ");
      text = text.replaceAll(/^[^\S\n\r]+/gm, "");
      text = text.replaceAll(/[^\S\n\r]+$/gm, "");
    }
  }
  return text;
};

// src/plugins/html-deserializer/utils/inlineTagNames.ts
var inlineTagNames = /* @__PURE__ */ new Set([
  "A",
  "ABBR",
  "B",
  "BDI",
  "BDO",
  "BR",
  "CITE",
  "CODE",
  "DATA",
  "DFN",
  "EM",
  "I",
  "KBD",
  "MARK",
  "Q",
  "S",
  "SAMP",
  "SMALL",
  "SPAN",
  "STRONG",
  "SUB",
  "SUP",
  "TIME",
  "U",
  "VAR",
  "WBR",
  "IMG",
  "MAP",
  "TRACK",
  "VIDEO",
  "EMBED",
  "IFRAME",
  "OBJECT",
  "PICTURE",
  "PORTAL",
  "SOURCE",
  "svg",
  "math",
  "CANVAS",
  "DEL",
  "INS",
  "BUTTON",
  "INPUT",
  "LABEL",
  "METER",
  "OUTPUT",
  "PROGRESS",
  "SELECT",
  "TEXTAREA",
  "ACRONYM",
  "BIG",
  "CONTENT",
  "FONT",
  "IMG",
  "MARQUEE",
  "MENUITEM",
  "NOBR",
  "SHADOW",
  "STRIKE",
  "TT"
]);

// src/plugins/html-deserializer/utils/isHtmlElement.ts
var isHtmlElement = (node) => node.nodeType === Node.ELEMENT_NODE;

// src/plugins/html-deserializer/utils/isHtmlInlineElement.ts
var isHtmlInlineElement = (node) => {
  if (!isHtmlElement(node))
    return false;
  const element = node;
  const tagNameIsInline = inlineTagNames.has(element.tagName);
  const displayProperty = element.style.display.split(" ")[0];
  if (displayProperty === "") {
    return tagNameIsInline;
  }
  if (displayProperty.startsWith("inline")) {
    return true;
  }
  if (displayProperty === "inherit" && element.parentElement) {
    return isHtmlInlineElement(element.parentElement);
  }
  if (["initial", "unset", "revert", "revert-layer", "contents", "none"].includes(
    displayProperty
  )) {
    return tagNameIsInline;
  }
  return false;
};

// src/plugins/html-deserializer/utils/isHtmlText.ts
var isHtmlText = (node) => node.nodeType === Node.TEXT_NODE;

// src/plugins/html-deserializer/utils/isHtmlBlockElement.ts
var isHtmlBlockElement = (node) => {
  if (!isHtmlElement(node))
    return false;
  const element = node;
  return !isHtmlInlineElement(element);
};

// src/plugins/html-deserializer/utils/collapse-white-space/isLastNonEmptyTextOfInlineFormattingContext.ts
var isLastNonEmptyTextOfInlineFormattingContext = (initialText) => {
  let currentNode = initialText;
  while (true) {
    if (currentNode.nextSibling) {
      currentNode = currentNode.nextSibling;
    } else {
      currentNode = currentNode.parentElement;
      if (currentNode && isHtmlBlockElement(currentNode)) {
        return true;
      }
      currentNode = (currentNode == null ? void 0 : currentNode.nextSibling) || null;
    }
    if (!currentNode) {
      return true;
    }
    if (isHtmlBlockElement(currentNode)) {
      return true;
    }
    if ((currentNode.textContent || "").length > 0) {
      return false;
    }
  }
};

// src/plugins/html-deserializer/utils/collapse-white-space/stateTransforms.ts
var upsertInlineFormattingContext = (state) => {
  if (state.inlineFormattingContext) {
    state.inlineFormattingContext.atStart = false;
  } else {
    state.inlineFormattingContext = {
      atStart: true,
      lastHasTrailingWhiteSpace: false
    };
  }
};
var endInlineFormattingContext = (state) => {
  state.inlineFormattingContext = null;
};

// src/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceText.ts
var collapseWhiteSpaceText = (text, state) => {
  const textContent = text.textContent || "";
  const isWhiteSpaceOnly = textContent.trim() === "";
  if (state.inlineFormattingContext || !isWhiteSpaceOnly) {
    upsertInlineFormattingContext(state);
  }
  const { whiteSpaceRule } = state;
  const trimStart = (() => {
    if (whiteSpaceRule !== "normal")
      return "collapse";
    if (!state.inlineFormattingContext || state.inlineFormattingContext.atStart || state.inlineFormattingContext.lastHasTrailingWhiteSpace)
      return "all";
    return "collapse";
  })();
  const trimEnd = (() => {
    if (whiteSpaceRule === "normal")
      return "collapse";
    if (isLastNonEmptyTextOfInlineFormattingContext(text))
      return "single-newline";
    return "collapse";
  })();
  const shouldCollapseWhiteSpace = {
    normal: true,
    pre: false,
    "pre-line": true
  }[whiteSpaceRule];
  const whiteSpaceIncludesNewlines = whiteSpaceRule !== "pre-line";
  const collapsedTextContent = collapseString(textContent || "", {
    trimStart,
    trimEnd,
    shouldCollapseWhiteSpace,
    whiteSpaceIncludesNewlines
  });
  if (state.inlineFormattingContext && shouldCollapseWhiteSpace) {
    state.inlineFormattingContext.lastHasTrailingWhiteSpace = collapsedTextContent.endsWith(" ");
  }
  text.textContent = collapsedTextContent;
};

// src/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceNode.ts
var collapseWhiteSpaceNode = (node, state) => {
  if (isHtmlElement(node)) {
    collapseWhiteSpaceElement(node, state);
    return;
  }
  if (isHtmlText(node)) {
    collapseWhiteSpaceText(node, state);
    return;
  }
  collapseWhiteSpaceChildren(node, state);
};

// src/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceChildren.ts
var collapseWhiteSpaceChildren = (node, state) => {
  const childNodes = Array.from(node.childNodes);
  for (const childNode of childNodes) {
    collapseWhiteSpaceNode(childNode, state);
  }
};

// src/plugins/html-deserializer/utils/collapse-white-space/inferWhiteSpaceRule.ts
var inferWhiteSpaceRule = (element) => {
  const whiteSpaceProperty = element.style.whiteSpace;
  switch (whiteSpaceProperty) {
    case "normal":
    case "nowrap": {
      return "normal";
    }
    case "pre":
    case "pre-wrap":
    case "break-spaces": {
      return "pre";
    }
    case "pre-line": {
      return "pre-line";
    }
  }
  if (element.tagName === "PRE") {
    return "pre";
  }
  if (whiteSpaceProperty === "initial") {
    return "normal";
  }
  return null;
};

// src/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpaceElement.ts
var collapseWhiteSpaceElement = (element, state) => {
  const isInlineElement = isHtmlInlineElement(element);
  const previousWhiteSpaceRule = state.whiteSpaceRule;
  const inferredWhiteSpaceRule = inferWhiteSpaceRule(element);
  if (inferredWhiteSpaceRule) {
    state.whiteSpaceRule = inferredWhiteSpaceRule;
  }
  if (!isInlineElement) {
    endInlineFormattingContext(state);
  }
  collapseWhiteSpaceChildren(element, state);
  if (!isInlineElement) {
    endInlineFormattingContext(state);
  }
  state.whiteSpaceRule = previousWhiteSpaceRule;
};

// src/plugins/html-deserializer/utils/collapse-white-space/collapseWhiteSpace.ts
var collapseWhiteSpace = (element) => {
  const clonedElement = element.cloneNode(true);
  const state = {
    inlineFormattingContext: null,
    whiteSpaceRule: "normal"
  };
  collapseWhiteSpaceElement(clonedElement, state);
  return clonedElement;
};

// src/plugins/html-deserializer/utils/htmlBodyToFragment.ts
import { jsx } from "slate-hyperscript";

// src/plugins/html-deserializer/utils/deserializeHtmlNodeChildren.ts
var deserializeHtmlNodeChildren = (editor, node) => Array.from(node.childNodes).flatMap(
  deserializeHtmlNode(editor)
);

// src/plugins/html-deserializer/utils/htmlBodyToFragment.ts
var htmlBodyToFragment = (editor, element) => {
  if (element.nodeName === "BODY") {
    return jsx(
      "fragment",
      {},
      deserializeHtmlNodeChildren(editor, element)
    );
  }
};

// src/plugins/html-deserializer/utils/htmlBrToNewLine.ts
var htmlBrToNewLine = (node) => {
  if (node.nodeName === "BR") {
    return "\n";
  }
};

// src/plugins/html-deserializer/utils/htmlElementToElement.ts
import { jsx as jsx2 } from "slate-hyperscript";

// src/plugins/html-deserializer/utils/pluginDeserializeHtml.ts
import { isDefined } from "@udecode/utils";
import castArray from "lodash/castArray.js";
var pluginDeserializeHtml = (editor, plugin, {
  element: el,
  deserializeLeaf
}) => {
  var _a;
  const {
    deserializeHtml: deserializeHtml2,
    isElement: isElementRoot,
    isLeaf: isLeafRoot,
    type
  } = plugin;
  if (!deserializeHtml2)
    return;
  const {
    attributeNames,
    query,
    isLeaf: isLeafRule,
    isElement: isElementRule,
    rules
  } = deserializeHtml2;
  let { getNode } = deserializeHtml2;
  const isElement4 = isElementRule || isElementRoot;
  const isLeaf = isLeafRule || isLeafRoot;
  if (!deserializeLeaf && !isElement4) {
    return;
  }
  if (deserializeLeaf && !isLeaf) {
    return;
  }
  if (rules) {
    const isValid = rules.some(
      ({ validNodeName = "*", validStyle, validClassName, validAttribute }) => {
        var _a2;
        if (validNodeName) {
          const validNodeNames = castArray(validNodeName);
          if (validNodeNames.length > 0 && !validNodeNames.includes(el.nodeName) && validNodeName !== "*")
            return false;
        }
        if (validClassName && !el.classList.contains(validClassName))
          return false;
        if (validStyle) {
          for (const [key, value] of Object.entries(validStyle)) {
            const values2 = castArray(value);
            if (!values2.includes(el.style[key]) && value !== "*")
              return;
            if (value === "*" && !el.style[key])
              return;
            const defaultNodeValue = (_a2 = plugin.inject.props) == null ? void 0 : _a2.defaultNodeValue;
            if (defaultNodeValue && defaultNodeValue === el.style[key]) {
              return false;
            }
          }
        }
        if (validAttribute) {
          if (typeof validAttribute === "string") {
            if (!el.getAttributeNames().includes(validAttribute))
              return false;
          } else {
            for (const [attributeName, attributeValue] of Object.entries(
              validAttribute
            )) {
              const attributeValues = castArray(attributeValue);
              const elAttribute = el.getAttribute(attributeName);
              if (!isDefined(elAttribute) || !attributeValues.includes(elAttribute))
                return false;
            }
          }
        }
        return true;
      }
    );
    if (!isValid)
      return;
  }
  if (query && !query(el)) {
    return;
  }
  if (!getNode) {
    if (isElement4) {
      getNode = () => ({ type });
    } else if (isLeaf) {
      getNode = () => ({ [type]: true });
    } else {
      return;
    }
  }
  let node = (_a = getNode(el, {})) != null ? _a : {};
  if (Object.keys(node).length === 0)
    return;
  const injectedPlugins = getInjectedPlugins(editor, plugin);
  injectedPlugins.forEach((injectedPlugin) => {
    var _a2, _b;
    const res = (_b = (_a2 = injectedPlugin.deserializeHtml) == null ? void 0 : _a2.getNode) == null ? void 0 : _b.call(_a2, el, node);
    if (res) {
      node = __spreadValues(__spreadValues({}, node), res);
    }
  });
  if (attributeNames) {
    const elementAttributes = {};
    const elementAttributeNames = el.getAttributeNames();
    for (const elementAttributeName of elementAttributeNames) {
      if (attributeNames.includes(elementAttributeName)) {
        elementAttributes[elementAttributeName] = el.getAttribute(elementAttributeName);
      }
    }
    if (Object.keys(elementAttributes).length > 0) {
      node.attributes = elementAttributes;
    }
  }
  return __spreadProps(__spreadValues({}, deserializeHtml2), { node });
};

// src/plugins/html-deserializer/utils/pipeDeserializeHtmlElement.ts
var pipeDeserializeHtmlElement = (editor, element) => {
  let result;
  [...editor.plugins].reverse().some((plugin) => {
    result = pluginDeserializeHtml(editor, plugin, { element });
    return !!result;
  });
  return result;
};

// src/plugins/html-deserializer/utils/htmlElementToElement.ts
var htmlElementToElement = (editor, element) => {
  var _a;
  const deserialized = pipeDeserializeHtmlElement(editor, element);
  if (deserialized) {
    const { node, withoutChildren } = deserialized;
    let descendants = (_a = node.children) != null ? _a : deserializeHtmlNodeChildren(editor, element);
    if (descendants.length === 0 || withoutChildren) {
      descendants = [{ text: "" }];
    }
    return jsx2("element", node, descendants);
  }
};

// src/plugins/html-deserializer/utils/htmlElementToLeaf.ts
import {
  isElement as isElement2,
  isText as isText2
} from "@udecode/slate";
import { jsx as jsx3 } from "slate-hyperscript";

// src/plugins/html-deserializer/utils/pipeDeserializeHtmlLeaf.ts
var pipeDeserializeHtmlLeaf = (editor, element) => {
  let node = {};
  [...editor.plugins].reverse().forEach((plugin) => {
    const deserialized = pluginDeserializeHtml(editor, plugin, {
      element,
      deserializeLeaf: true
    });
    if (!deserialized)
      return;
    node = __spreadValues(__spreadValues({}, node), deserialized.node);
  });
  return node;
};

// src/plugins/html-deserializer/utils/htmlElementToLeaf.ts
var htmlElementToLeaf = (editor, element) => {
  const node = pipeDeserializeHtmlLeaf(editor, element);
  return deserializeHtmlNodeChildren(editor, element).reduce(
    (arr, child) => {
      if (!child)
        return arr;
      if (isElement2(child)) {
        if (Object.keys(node).length > 0) {
          mergeDeepToNodes({
            node: child,
            source: node,
            query: {
              filter: ([n]) => isText2(n)
            }
          });
        }
        arr.push(child);
      } else {
        const attributes = __spreadValues({}, node);
        if (isText2(child) && child.text) {
          Object.keys(attributes).forEach((key) => {
            if (attributes[key] && child[key]) {
              attributes[key] = child[key];
            }
          });
        }
        arr.push(jsx3("text", attributes, child));
      }
      return arr;
    },
    []
  );
};

// src/plugins/html-deserializer/utils/htmlTextNodeToString.ts
var htmlTextNodeToString = (node) => {
  if (isHtmlText(node)) {
    return node.textContent || "";
  }
};

// src/plugins/html-deserializer/utils/deserializeHtmlNode.ts
var deserializeHtmlNode = (editor) => (node) => {
  const textNode = htmlTextNodeToString(node);
  if (textNode)
    return textNode;
  if (!isHtmlElement(node))
    return null;
  const breakLine = htmlBrToNewLine(node);
  if (breakLine)
    return breakLine;
  const fragment = htmlBodyToFragment(editor, node);
  if (fragment)
    return fragment;
  const element = htmlElementToElement(editor, node);
  if (element)
    return element;
  return htmlElementToLeaf(editor, node);
};

// src/plugins/html-deserializer/utils/deserializeHtmlElement.ts
var deserializeHtmlElement = (editor, element) => {
  return deserializeHtmlNode(editor)(element);
};

// src/plugins/html-deserializer/utils/htmlStringToDOMNode.ts
var htmlStringToDOMNode = (rawHtml) => {
  const node = document.createElement("body");
  node.innerHTML = rawHtml;
  return node;
};

// src/plugins/html-deserializer/utils/deserializeHtml.ts
var deserializeHtml = (editor, {
  element,
  collapseWhiteSpace: shouldCollapseWhiteSpace = true
}) => {
  if (typeof element === "string") {
    element = htmlStringToDOMNode(element);
  }
  if (shouldCollapseWhiteSpace) {
    element = collapseWhiteSpace(element);
  }
  const fragment = deserializeHtmlElement(editor, element);
  return normalizeDescendantsToDocumentFragment(editor, {
    descendants: fragment
  });
};

// src/plugins/html-deserializer/utils/parseHtmlDocument.ts
var parseHtmlDocument = (html) => {
  return new DOMParser().parseFromString(html, "text/html");
};

// src/plugins/html-deserializer/createDeserializeHtmlPlugin.ts
var KEY_DESERIALIZE_HTML = "deserializeHtml";
var createDeserializeHtmlPlugin = createPluginFactory({
  key: KEY_DESERIALIZE_HTML,
  then: (editor) => ({
    editor: {
      insertData: {
        format: "text/html",
        getFragment: ({ data }) => {
          const document2 = parseHtmlDocument(data);
          return deserializeHtml(editor, {
            element: document2.body
          });
        }
      }
    }
  })
});

// src/plugins/html-deserializer/utils/traverseHtmlNode.ts
var traverseHtmlNode = (node, callback) => {
  const keepTraversing = callback(node);
  if (!keepTraversing) {
    return;
  }
  let child = node.firstChild;
  while (child) {
    const currentChild = child;
    const previousChild = child.previousSibling;
    child = child.nextSibling;
    traverseHtmlNode(currentChild, callback);
    if (
      // An unwrap was made. Need to compute the next child again.
      !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && previousChild !== child.previousSibling && child.parentNode
    ) {
      child = previousChild ? previousChild.nextSibling : node.firstChild;
    } else if (
      // A list was created. Need to compute the next child again.
      !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && !child.previousSibling && !child.nextSibling && !child.parentNode
    ) {
      if (previousChild) {
        child = previousChild.nextSibling ? previousChild.nextSibling.nextSibling : null;
      } else if (node.firstChild) {
        child = node.firstChild.nextSibling;
      }
    }
  }
};

// src/plugins/html-deserializer/utils/traverseHtmlElements.ts
var traverseHtmlElements = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlElement(node)) {
      return true;
    }
    return callback(node);
  });
};

// src/plugins/html-deserializer/utils/cleanHtmlBrElements.ts
var cleanHtmlBrElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName !== "BR") {
      return true;
    }
    const replacementTextNode = document.createTextNode(LINE_FEED);
    if (element.parentElement) {
      element.parentElement.replaceChild(replacementTextNode, element);
    }
    return false;
  });
};

// src/plugins/html-deserializer/utils/cleanHtmlCrLf.ts
var cleanHtmlCrLf = (html) => {
  return html.replaceAll(/(\r\n|\r)/g, "\n");
};

// src/plugins/html-deserializer/utils/cleanHtmlEmptyElements.ts
var ALLOWED_EMPTY_ELEMENTS = /* @__PURE__ */ new Set(["BR", "IMG", "TH", "TD"]);
var isEmpty = (element) => {
  return !ALLOWED_EMPTY_ELEMENTS.has(element.nodeName) && !element.innerHTML.trim();
};
var removeIfEmpty = (element) => {
  if (isEmpty(element)) {
    const { parentElement } = element;
    element.remove();
    if (parentElement) {
      removeIfEmpty(parentElement);
    }
  }
};
var cleanHtmlEmptyElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    removeIfEmpty(element);
    return true;
  });
};

// src/plugins/html-deserializer/utils/replaceTagName.ts
var replaceTagName = (element, tagName) => {
  const newElement = document.createElement(tagName);
  newElement.innerHTML = element.innerHTML;
  for (const { name } of element.attributes) {
    const value = element.getAttribute(name);
    if (value) {
      newElement.setAttribute(name, value);
    }
  }
  if (element.parentNode) {
    element.parentNode.replaceChild(newElement, element);
  }
  return newElement;
};

// src/plugins/html-deserializer/utils/cleanHtmlFontElements.ts
var cleanHtmlFontElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName === "FONT") {
      if (element.textContent) {
        replaceTagName(element, "span");
      } else {
        element.remove();
      }
    }
    return true;
  });
};

// src/plugins/html-deserializer/utils/isHtmlFragmentHref.ts
var isHtmlFragmentHref = (href) => href.startsWith("#");

// src/plugins/html-deserializer/utils/unwrapHtmlElement.ts
var unwrapHtmlElement = (element) => {
  element.outerHTML = element.innerHTML;
};

// src/plugins/html-deserializer/utils/cleanHtmlLinkElements.ts
var cleanHtmlLinkElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName !== "A") {
      return true;
    }
    const href = element.getAttribute("href");
    if (!href || isHtmlFragmentHref(href)) {
      unwrapHtmlElement(element);
    }
    if (href && element.querySelector("img")) {
      for (const span of element.querySelectorAll("span")) {
        if (!span.textContent) {
          unwrapHtmlElement(span);
        }
      }
    }
    return true;
  });
};

// src/plugins/html-deserializer/utils/traverseHtmlTexts.ts
var traverseHtmlTexts = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlText(node)) {
      return true;
    }
    return callback(node);
  });
};

// src/plugins/html-deserializer/utils/cleanHtmlTextNodes.ts
var cleanHtmlTextNodes = (rootNode) => {
  traverseHtmlTexts(rootNode, (textNode) => {
    if (/^\n\s*$/.test(textNode.data) && (textNode.previousElementSibling || textNode.nextElementSibling)) {
      textNode.remove();
      return true;
    }
    textNode.data = textNode.data.replaceAll(/\n\s*/g, "\n");
    if (textNode.data.includes(CARRIAGE_RETURN) || textNode.data.includes(LINE_FEED) || textNode.data.includes(NO_BREAK_SPACE)) {
      const hasSpace = textNode.data.includes(SPACE);
      const hasNonWhitespace = /\S/.test(textNode.data);
      const hasLineFeed = textNode.data.includes(LINE_FEED);
      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {
        if (textNode.data === NO_BREAK_SPACE) {
          textNode.data = SPACE;
          return true;
        }
        textNode.remove();
        return true;
      }
      if (textNode.previousSibling && textNode.previousSibling.nodeName === "BR" && textNode.parentElement) {
        textNode.previousSibling.remove();
        const matches = textNode.data.match(/^[\n\r]+/);
        const offset = matches ? matches[0].length : 0;
        textNode.data = textNode.data.slice(Math.max(0, offset)).replaceAll(new RegExp(LINE_FEED, "g"), SPACE).replaceAll(new RegExp(CARRIAGE_RETURN, "g"), SPACE);
        textNode.data = `
${textNode.data}`;
      } else {
        textNode.data = textNode.data.replaceAll(new RegExp(LINE_FEED, "g"), SPACE).replaceAll(new RegExp(CARRIAGE_RETURN, "g"), SPACE);
      }
    }
    return true;
  });
};

// src/plugins/html-deserializer/utils/isHtmlTable.ts
var isHtmlTable = (element) => element.nodeName === "TABLE";

// src/plugins/html-deserializer/utils/copyBlockMarksToSpanChild.ts
var copyBlockMarksToSpanChild = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    const el = element;
    const styleAttribute = element.getAttribute("style");
    if (!styleAttribute)
      return true;
    if (isHtmlBlockElement(el) && !isHtmlTable(el)) {
      const {
        style: {
          backgroundColor,
          color,
          fontFamily,
          fontSize,
          fontStyle,
          fontWeight,
          textDecoration
        }
      } = el;
      if (backgroundColor || color || fontFamily || fontSize || fontStyle || fontWeight || textDecoration) {
        const span = document.createElement("span");
        if (!["initial", "inherit"].includes(color)) {
          span.style.color = color;
        }
        span.style.fontFamily = fontFamily;
        span.style.fontSize = fontSize;
        if (!["normal", "initial", "inherit"].includes(color)) {
          span.style.fontStyle = fontStyle;
        }
        if (!["normal", 400].includes(fontWeight)) {
          span.style.fontWeight = fontWeight;
        }
        span.style.textDecoration = textDecoration;
        span.innerHTML = el.innerHTML;
        element.innerHTML = span.outerHTML;
      }
    }
    return true;
  });
};

// src/plugins/html-deserializer/utils/findHtmlElement.ts
var findHtmlElement = (rootNode, predicate) => {
  let res = null;
  traverseHtmlElements(rootNode, (node) => {
    if (predicate(node)) {
      res = node;
      return false;
    }
    return true;
  });
  return res;
};
var someHtmlElement = (rootNode, predicate) => {
  return !!findHtmlElement(rootNode, predicate);
};

// src/plugins/html-deserializer/utils/getHtmlComments.ts
var acceptNode = () => NodeFilter.FILTER_ACCEPT;
var getHtmlComments = (node) => {
  const comments = [];
  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode
  });
  let currentNode = iterator.nextNode();
  while (currentNode) {
    if (currentNode.nodeValue) {
      comments.push(currentNode.nodeValue);
    }
    currentNode = iterator.nextNode();
  }
  return comments;
};

// src/plugins/html-deserializer/utils/isHtmlComment.ts
var isHtmlComment = (node) => node.nodeType === Node.COMMENT_NODE;

// src/plugins/html-deserializer/utils/isOlSymbol.ts
var isOlSymbol = (symbol) => {
  return /[\da-np-z]\S/.test(symbol.toLowerCase());
};

// src/plugins/html-deserializer/utils/parseHtmlElement.ts
var parseHtmlElement = (html) => {
  const { body } = parseHtmlDocument(html);
  return body.firstElementChild;
};

// src/plugins/html-deserializer/utils/postCleanHtml.ts
var postCleanHtml = (html) => {
  const cleanHtml = html.trim().replaceAll(new RegExp(ZERO_WIDTH_SPACE, "g"), "");
  return `<body>${cleanHtml}</body>`;
};

// src/plugins/html-deserializer/utils/removeHtmlSurroundings.ts
var removeBeforeHtml = (html) => {
  const index = html.indexOf("<html");
  if (index === -1) {
    return html;
  }
  return html.slice(Math.max(0, index));
};
var removeAfterHtml = (html) => {
  const index = html.lastIndexOf("</html>");
  if (index === -1) {
    return html;
  }
  return html.slice(0, Math.max(0, index + "</html>".length));
};
var removeHtmlSurroundings = (html) => {
  return removeBeforeHtml(removeAfterHtml(html));
};

// src/plugins/html-deserializer/utils/preCleanHtml.ts
var cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];
var preCleanHtml = (html) => {
  return cleaners.reduce((result, clean) => clean(result), html);
};

// src/plugins/html-deserializer/utils/traverseHtmlComments.ts
var traverseHtmlComments = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlComment(node)) {
      return true;
    }
    return callback(node);
  });
};

// src/plugins/html-deserializer/utils/removeHtmlNodesBetweenComments.ts
var removeHtmlNodesBetweenComments = (rootNode, start, end) => {
  const isClosingComment = (node) => isHtmlComment(node) && node.data === end;
  traverseHtmlComments(rootNode, (comment) => {
    if (comment.data === start) {
      let node = comment.nextSibling;
      comment.remove();
      while (node && !isClosingComment(node)) {
        const { nextSibling } = node;
        node.remove();
        node = nextSibling;
      }
      if (node && isClosingComment(node)) {
        node.remove();
      }
    }
    return true;
  });
};

// src/utils/flattenDeepPlugins.ts
import defaultsDeep3 from "lodash/defaultsDeep.js";

// src/utils/mergeDeepPlugins.ts
import defaultsDeep2 from "lodash/defaultsDeep.js";
import keyBy from "lodash/keyBy.js";
import merge from "lodash/merge.js";
import values from "lodash/values.js";
var mergeDeepPlugins = (editor, _plugin) => {
  const plugin = __spreadValues({}, _plugin);
  const { then } = plugin;
  if (then) {
    delete plugin.then;
    const { plugins: pluginPlugins } = plugin;
    const pluginThen = mergeDeepPlugins(
      editor,
      defaultsDeep2(then(editor, plugin), plugin)
    );
    if (pluginPlugins && pluginThen.plugins) {
      const merged = merge(
        keyBy(pluginPlugins, "key"),
        keyBy(pluginThen.plugins, "key")
      );
      pluginThen.plugins = values(merged);
    }
    return pluginThen;
  }
  return plugin;
};

// src/utils/setDefaultPlugin.ts
var setDefaultPlugin = (plugin) => {
  if (plugin.type === void 0)
    plugin.type = plugin.key;
  if (!plugin.options)
    plugin.options = {};
  if (!plugin.inject)
    plugin.inject = {};
  if (!plugin.editor)
    plugin.editor = {};
  return plugin;
};

// src/utils/flattenDeepPlugins.ts
var flattenDeepPlugins = (editor, plugins) => {
  if (!plugins)
    return;
  plugins.forEach((plugin) => {
    let p = setDefaultPlugin(plugin);
    p = mergeDeepPlugins(editor, p);
    if (p.enabled === false)
      return;
    if (editor.pluginsByKey[p.key]) {
      const index = editor.plugins.indexOf(editor.pluginsByKey[p.key]);
      const mergedPlugin = defaultsDeep3(p, editor.pluginsByKey[p.key]);
      if (index >= 0) {
        editor.plugins[index] = mergedPlugin;
      }
      editor.pluginsByKey[p.key] = mergedPlugin;
    } else {
      editor.plugins.push(p);
      editor.pluginsByKey[p.key] = p;
    }
    flattenDeepPlugins(editor, p.plugins);
  });
};

// src/utils/setPlatePlugins.ts
var setPlatePlugins = (editor, {
  disableCorePlugins,
  plugins: _plugins = [],
  maxLength
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
  let plugins = [];
  if (disableCorePlugins !== true) {
    const dcp = disableCorePlugins;
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.react)) {
      plugins.push((_b = (_a = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _a.react) != null ? _b : createReactPlugin());
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.history)) {
      plugins.push(
        (_d = (_c = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _c.history) != null ? _d : createHistoryPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.nodeFactory)) {
      plugins.push(
        (_f = (_e = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _e[KEY_NODE_FACTORY]) != null ? _f : createNodeFactoryPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.eventEditor)) {
      plugins.push(
        (_h = (_g = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _g[KEY_EVENT_EDITOR]) != null ? _h : createEventEditorPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.inlineVoid)) {
      plugins.push(
        (_j = (_i = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _i[KEY_INLINE_VOID]) != null ? _j : createInlineVoidPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.insertData)) {
      plugins.push(
        (_l = (_k = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _k[KEY_INSERT_DATA]) != null ? _l : createInsertDataPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.selection)) {
      plugins.push(
        (_n = (_m = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _m[KEY_PREV_SELECTION]) != null ? _n : createPrevSelectionPlugin()
      );
    }
    if ((typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.length)) && isDefined2(maxLength)) {
      plugins.push(
        (_p = (_o = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _o[KEY_LENGTH]) != null ? _p : createLengthPlugin({
          options: {
            maxLength
          }
        })
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.deserializeHtml)) {
      plugins.push(
        (_r = (_q = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _q[KEY_DESERIALIZE_HTML]) != null ? _r : createDeserializeHtmlPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.deserializeAst)) {
      plugins.push(
        (_t = (_s = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _s[KEY_DESERIALIZE_AST]) != null ? _t : createDeserializeAstPlugin()
      );
    }
    if (typeof dcp !== "object" || !(dcp == null ? void 0 : dcp.editorProtocol)) {
      plugins.push(
        (_v = (_u = editor == null ? void 0 : editor.pluginsByKey) == null ? void 0 : _u[KEY_EDITOR_PROTOCOL]) != null ? _v : createEditorProtocolPlugin()
      );
    }
  }
  plugins = [...plugins, ..._plugins];
  editor.plugins = [];
  editor.pluginsByKey = {};
  flattenDeepPlugins(editor, plugins);
  editor.plugins.forEach((plugin) => {
    if (plugin.overrideByKey) {
      const newPlugins = editor.plugins.map((p) => {
        return overridePluginsByKey(p, plugin.overrideByKey);
      });
      editor.plugins = [];
      editor.pluginsByKey = {};
      flattenDeepPlugins(editor, newPlugins);
    }
  });
};

// src/plugins/withPlate.ts
var shouldHaveBeenOverridden = (fnName) => () => {
  console.warn(
    `editor.${fnName} should have been overriden but was not. Please report this issue here: https://github.com/udecode/plate/issues`
  );
};
var withPlate = (e, {
  id,
  plugins = [],
  disableCorePlugins,
  maxLength
} = {}) => {
  let editor = e;
  editor.id = id != null ? id : editor.id;
  editor.prevSelection = null;
  editor.isFallback = false;
  editor.currentKeyboardEvent = null;
  editor.reset = () => resetEditor(editor);
  editor.redecorate = () => shouldHaveBeenOverridden("redecorate");
  editor.plate = {
    get set() {
      shouldHaveBeenOverridden("plate.set");
      return null;
    }
  };
  if (!editor.key) {
    editor.key = Math.random();
  }
  setPlatePlugins(editor, {
    plugins,
    maxLength,
    disableCorePlugins
  });
  editor.plugins.forEach((plugin) => {
    if (plugin.withOverrides) {
      editor = plugin.withOverrides(editor, plugin);
    }
  });
  return editor;
};

// src/utils/createPlugins.tsx
import cloneDeep from "lodash/cloneDeep.js";
var createPlugins = (plugins, {
  components,
  overrideByKey
} = {}) => {
  let allOverrideByKey = {};
  if (overrideByKey) {
    allOverrideByKey = cloneDeep(overrideByKey);
  }
  if (components) {
    Object.keys(components).forEach((key) => {
      if (!allOverrideByKey[key])
        allOverrideByKey[key] = {};
      allOverrideByKey[key].component = components[key];
    });
  }
  if (Object.keys(allOverrideByKey).length > 0) {
    return plugins.map((plugin) => {
      return overridePluginsByKey(plugin, allOverrideByKey);
    });
  }
  return plugins;
};

// src/utils/createPlateEditor.ts
var createPlateEditor = (_a = {}) => {
  var _b = _a, {
    editor = createTEditor(),
    plugins = [],
    components,
    overrideByKey,
    normalizeInitialValue: shouldNormalizeInitialValue
  } = _b, withPlateOptions = __objRest(_b, [
    "editor",
    "plugins",
    "components",
    "overrideByKey",
    "normalizeInitialValue"
  ]);
  plugins = createPlugins(plugins, {
    components,
    overrideByKey
  });
  const e = withPlate(editor, __spreadValues({
    plugins
  }, withPlateOptions));
  if (shouldNormalizeInitialValue) {
    normalizeEditor(e, { force: true });
  }
  return e;
};

// src/utils/createPlateFallbackEditor.ts
var createPlateFallbackEditor = (options = {}) => {
  const editor = createPlateEditor(options);
  editor.isFallback = true;
  editor.apply = () => {
    throw new Error(
      "Cannot apply operations on the fallback editor. The fallback editor is used when a hook that depends on the Plate store was unable to locate a valid store. If you are using PlateController, use `useEditorMounted(id?: PlateId)` or `!editor.isFallback` to ensure that a valid Plate store is available before attempting to call operations on the editor."
    );
  };
  return editor;
};

// src/utils/getKeysByTypes.ts
import castArray2 from "lodash/castArray.js";
var getKeysByTypes = (editor, type) => {
  const types = castArray2(type);
  const found = Object.values(editor.pluginsByKey).filter((plugin) => {
    return types.includes(plugin.type);
  });
  return found.map((p) => p.key);
};

// src/utils/getKeyByType.ts
var getKeyByType = (editor, type) => {
  return getKeysByTypes(editor, type)[0];
};

// src/utils/getPluginInjectProps.ts
var getPluginInjectProps = (editor, key) => {
  var _a, _b;
  return (_b = (_a = getPlugin(editor, key).inject) == null ? void 0 : _a.props) != null ? _b : {};
};

// src/utils/getPluginOptions.ts
var getPluginOptions = (editor, key) => {
  var _a;
  return (_a = getPlugin(editor, key).options) != null ? _a : {};
};

// src/utils/getPluginTypes.ts
var getPluginTypes = (editor, keys) => keys.map((key) => getPluginType(editor, key));

// src/utils/getPlugins.ts
var getPlugins = (editor) => {
  var _a;
  return (_a = editor == null ? void 0 : editor.plugins) != null ? _a : [];
};

// src/utils/getRenderNodeProps.ts
import { clsx } from "clsx";

// src/utils/misc/getSlateClass.ts
var getSlateClass = (type) => `slate-${type}`;

// src/utils/getRenderNodeProps.ts
var getRenderNodeProps = ({
  attributes,
  nodeProps,
  props,
  type
}) => {
  var _a;
  let newProps = {};
  if (props) {
    newProps = (_a = typeof props === "function" ? props(nodeProps) : props) != null ? _a : {};
  }
  if (!newProps.nodeProps && attributes) {
    newProps.nodeProps = attributes;
  }
  nodeProps = __spreadValues(__spreadValues({}, nodeProps), newProps);
  if (nodeProps.nodeProps) {
    Object.keys(nodeProps.nodeProps).forEach((key) => {
      var _a2, _b;
      if (((_a2 = nodeProps.nodeProps) == null ? void 0 : _a2[key]) === void 0) {
        (_b = nodeProps.nodeProps) == null ? true : delete _b[key];
      }
    });
  }
  const { className } = nodeProps;
  return __spreadProps(__spreadValues({}, nodeProps), { className: clsx(getSlateClass(type), className) });
};

// src/utils/hotkeys.ts
import { isComposing } from "@udecode/slate-react";
import { IS_APPLE } from "@udecode/utils";
import { isKeyHotkey } from "is-hotkey";
import { isHotkey } from "is-hotkey";
var HOTKEYS = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  insertSoftBreak: "shift+enter",
  italic: "mod+i",
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  splitBlock: "enter",
  tab: "tab",
  untab: "shift+tab",
  undo: "mod+z"
};
var APPLE_HOTKEYS = {
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
};
var create = (key) => {
  const generic = HOTKEYS[key];
  const apple = APPLE_HOTKEYS[key];
  const windows = WINDOWS_HOTKEYS[key];
  const isGeneric = generic && isKeyHotkey(generic);
  const isApple = apple && isKeyHotkey(apple);
  const isWindows = windows && isKeyHotkey(windows);
  return (event) => {
    if (isGeneric && isGeneric(event))
      return true;
    if (IS_APPLE && isApple && isApple(event))
      return true;
    if (!IS_APPLE && isWindows && isWindows(event))
      return true;
    return false;
  };
};
var createComposing = (key) => (editor, event, {
  composing
} = {}) => {
  if (!create(key)(event))
    return false;
  if (!!composing !== isComposing(editor))
    return false;
  return true;
};
var Hotkeys = {
  isBold: create("bold"),
  isCompose: create("compose"),
  isMoveBackward: create("moveBackward"),
  isMoveForward: create("moveForward"),
  isDeleteBackward: create("deleteBackward"),
  isDeleteForward: create("deleteForward"),
  isDeleteLineBackward: create("deleteLineBackward"),
  isDeleteLineForward: create("deleteLineForward"),
  isDeleteWordBackward: create("deleteWordBackward"),
  isDeleteWordForward: create("deleteWordForward"),
  isExtendBackward: create("extendBackward"),
  isExtendForward: create("extendForward"),
  isExtendLineBackward: create("extendLineBackward"),
  isExtendLineForward: create("extendLineForward"),
  isItalic: create("italic"),
  isMoveLineBackward: create("moveLineBackward"),
  isMoveLineForward: create("moveLineForward"),
  isMoveWordBackward: create("moveWordBackward"),
  isMoveWordForward: create("moveWordForward"),
  isRedo: create("redo"),
  isSoftBreak: create("insertSoftBreak"),
  isSplitBlock: create("splitBlock"),
  isTab: createComposing("tab"),
  isTransposeCharacter: create("transposeCharacter"),
  isUndo: create("undo"),
  isUntab: createComposing("untab")
};

// src/utils/mapInjectPropsToPlugin.ts
var mapInjectPropsToPlugin = (editor, plugin, injectedPlugin) => {
  var _a;
  const validTypes = (_a = plugin.inject.props) == null ? void 0 : _a.validTypes;
  if (!validTypes)
    return;
  const keys = getKeysByTypes(editor, validTypes);
  const injected = {};
  keys.forEach((key) => {
    injected[key] = injectedPlugin;
  });
  return {
    inject: {
      pluginsByKey: injected
    }
  };
};

// src/utils/mergeDeepToNodes.ts
import merge2 from "lodash/merge.js";
var mergeDeepToNodes = (options) => {
  applyDeepToNodes(__spreadProps(__spreadValues({}, options), { apply: merge2 }));
};

// src/utils/mockPlugin.ts
var mockPlugin = (plugin) => __spreadValues({
  key: "",
  type: "",
  editor: {},
  inject: {},
  options: {}
}, plugin);

// src/utils/normalizeInitialValue.ts
import cloneDeep2 from "lodash/cloneDeep.js";
import isEqual from "lodash/isEqual.js";
var normalizeInitialValue = (editor, value) => {
  let normalizedValue = cloneDeep2(value);
  editor.plugins.forEach((p) => {
    var _a;
    const _normalizedValue = (_a = p.normalizeInitialValue) == null ? void 0 : _a.call(p, normalizedValue);
    if (_normalizedValue) {
      normalizedValue = _normalizedValue;
    }
  });
  if (!isEqual(value, normalizedValue)) {
    return normalizedValue;
  }
};

// src/utils/pipeDecorate.ts
var pipeDecorate = (editor, decorateProp) => {
  const decorates = editor.plugins.flatMap(
    (plugin) => {
      var _a, _b;
      return (_b = (_a = plugin.decorate) == null ? void 0 : _a.call(plugin, editor, plugin)) != null ? _b : [];
    }
  );
  if (decorateProp) {
    decorates.push(decorateProp);
  }
  if (decorates.length === 0)
    return;
  return (entry) => {
    let ranges = [];
    const addRanges = (newRanges) => {
      if (newRanges == null ? void 0 : newRanges.length)
        ranges = [...ranges, ...newRanges];
    };
    decorates.forEach((decorate) => {
      addRanges(decorate(entry));
    });
    return ranges;
  };
};

// src/utils/pipeHandler.ts
var convertDomEventToSyntheticEvent = (domEvent) => {
  let propagationStopped = false;
  return __spreadProps(__spreadValues({}, domEvent), {
    nativeEvent: domEvent,
    currentTarget: domEvent.currentTarget,
    target: domEvent.target,
    bubbles: domEvent.bubbles,
    cancelable: domEvent.cancelable,
    defaultPrevented: domEvent.defaultPrevented,
    eventPhase: domEvent.eventPhase,
    isTrusted: domEvent.isTrusted,
    timeStamp: domEvent.timeStamp,
    type: domEvent.type,
    isDefaultPrevented: () => domEvent.defaultPrevented,
    isPropagationStopped: () => propagationStopped,
    persist: () => {
      throw new Error(
        "persist is not implemented for synthetic events created using convertDomEventToSyntheticEvent"
      );
    },
    preventDefault: () => domEvent.preventDefault(),
    stopPropagation: () => {
      propagationStopped = true;
      domEvent.stopPropagation();
    }
  });
};
var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  const shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.isPropagationStopped();
};
var pipeHandler = (editor, {
  editableProps,
  handlerKey
}) => {
  let pluginsHandlers = [];
  pluginsHandlers = editor.plugins.flatMap(
    (plugin) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = plugin.handlers) == null ? void 0 : _a[handlerKey]) == null ? void 0 : _b.call(_a, editor, plugin)) != null ? _c : [];
    }
  );
  const propsHandler = editableProps == null ? void 0 : editableProps[handlerKey];
  if (pluginsHandlers.length === 0 && !propsHandler)
    return;
  return (event) => {
    const isDomEvent = event instanceof Event;
    const handledEvent = isDomEvent ? convertDomEventToSyntheticEvent(event) : event;
    const eventIsHandled = pluginsHandlers.some(
      (handler) => isEventHandled(handledEvent, handler)
    );
    if (eventIsHandled)
      return true;
    return isEventHandled(handledEvent, propsHandler);
  };
};

// src/utils/pluginInjectProps.ts
import { isElement as isElement3 } from "@udecode/slate";
import { isDefined as isDefined3 } from "@udecode/utils";
import { clsx as clsx2 } from "clsx";
var pluginInjectProps = (editor, { key, inject: { props } }, nodeProps) => {
  var _a, _b, _c, _d;
  const { element, text, className, style } = nodeProps;
  const node = element != null ? element : text;
  if (!node)
    return;
  if (!props)
    return;
  const {
    nodeKey = key,
    styleKey = nodeKey,
    validTypes,
    classNames,
    transformClassName,
    transformNodeValue,
    transformProps,
    transformStyle,
    validNodeValues,
    defaultNodeValue,
    query
  } = props;
  const queryResult = query == null ? void 0 : query(props, nodeProps);
  if (!queryResult && validTypes && isElement3(node) && node.type && !validTypes.includes(node.type)) {
    return;
  }
  const nodeValue = node[nodeKey];
  if (!queryResult && (!isDefined3(nodeValue) || validNodeValues && !validNodeValues.includes(nodeValue) || nodeValue === defaultNodeValue)) {
    return;
  }
  const transformOptions = __spreadProps(__spreadValues({}, nodeProps), { nodeValue });
  const value = (_a = transformNodeValue == null ? void 0 : transformNodeValue(transformOptions)) != null ? _a : nodeValue;
  transformOptions.value = value;
  let res = {};
  if (element) {
    res.className = clsx2(className, `slate-${nodeKey}-${nodeValue}`);
  }
  if ((classNames == null ? void 0 : classNames[nodeValue]) || transformClassName) {
    res.className = (_b = transformClassName == null ? void 0 : transformClassName(transformOptions)) != null ? _b : clsx2(className, classNames == null ? void 0 : classNames[value]);
  }
  if (styleKey) {
    res.style = (_c = transformStyle == null ? void 0 : transformStyle(transformOptions)) != null ? _c : __spreadProps(__spreadValues({}, style), {
      [styleKey]: value
    });
  }
  if (transformProps) {
    res = (_d = transformProps(transformOptions, res)) != null ? _d : res;
  }
  return res;
};

// src/utils/pipeInjectProps.tsx
var pipeInjectProps = (editor, nodeProps) => {
  editor.plugins.forEach((plugin) => {
    if (plugin.inject.props) {
      const props = pluginInjectProps(editor, plugin, nodeProps);
      if (props) {
        nodeProps = __spreadValues(__spreadValues({}, nodeProps), props);
      }
    }
  });
  return __spreadProps(__spreadValues({}, nodeProps), { editor });
};

// src/utils/pipeOnChange.ts
var pipeOnChange = (editor) => {
  const onChanges = editor.plugins.flatMap(
    (plugin) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = plugin.handlers) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, editor, plugin)) != null ? _c : [];
    }
  );
  return (nodes) => {
    return onChanges.some((handler) => {
      if (!handler) {
        return false;
      }
      const shouldTreatEventAsHandled = handler(nodes);
      if (shouldTreatEventAsHandled != null) {
        return shouldTreatEventAsHandled;
      }
      return false;
    });
  };
};

// src/utils/pipeRenderElement.tsx
import React3 from "react";
import { DefaultElement as DefaultElement2 } from "slate-react";

// src/utils/pluginRenderElement.tsx
import React2 from "react";
import { DefaultElement } from "slate-react";
var pluginRenderElement = (editor, { key, type, component: _component, props }) => function render(nodeProps) {
  const { element, children: _children } = nodeProps;
  if (element.type === type) {
    const Element = _component != null ? _component : DefaultElement;
    const injectAboveComponents = editor.plugins.flatMap(
      (o) => {
        var _a, _b;
        return (_b = (_a = o.inject) == null ? void 0 : _a.aboveComponent) != null ? _b : [];
      }
    );
    const injectBelowComponents = editor.plugins.flatMap(
      (o) => {
        var _a, _b;
        return (_b = (_a = o.inject) == null ? void 0 : _a.belowComponent) != null ? _b : [];
      }
    );
    nodeProps = getRenderNodeProps({
      attributes: element.attributes,
      nodeProps,
      props,
      type
    });
    let children = _children;
    injectBelowComponents.forEach((withHOC2) => {
      const hoc = withHOC2(__spreadProps(__spreadValues({}, nodeProps), { key }));
      if (hoc) {
        children = hoc(__spreadProps(__spreadValues({}, nodeProps), { children }));
      }
    });
    let component = /* @__PURE__ */ React2.createElement(Element, __spreadValues({}, nodeProps), children);
    injectAboveComponents.forEach((withHOC2) => {
      const hoc = withHOC2(__spreadProps(__spreadValues({}, nodeProps), { key }));
      if (hoc) {
        component = hoc(__spreadProps(__spreadValues({}, nodeProps), { children: component }));
      }
    });
    return /* @__PURE__ */ React2.createElement(ElementProvider, { element, scope: key }, component);
  }
};

// src/utils/pipeRenderElement.tsx
var pipeRenderElement = (editor, renderElementProp) => {
  const renderElements = [];
  editor.plugins.forEach((plugin) => {
    if (plugin.isElement) {
      renderElements.push(pluginRenderElement(editor, plugin));
    }
  });
  return function render(nodeProps) {
    const props = pipeInjectProps(editor, nodeProps);
    let element;
    renderElements.some((renderElement) => {
      element = renderElement(props);
      return !!element;
    });
    if (element)
      return element;
    if (renderElementProp) {
      return renderElementProp(props);
    }
    return /* @__PURE__ */ React3.createElement(DefaultElement2, __spreadValues({}, props));
  };
};

// src/utils/pipeRenderLeaf.tsx
import React5 from "react";

// src/utils/pluginRenderLeaf.tsx
import React4 from "react";
var pluginRenderLeaf = (editor, { key, type = key, component, props }) => function render(nodeProps) {
  const { leaf, children } = nodeProps;
  if (leaf[type]) {
    const Leaf = component != null ? component : DefaultLeaf;
    nodeProps = getRenderNodeProps({
      attributes: leaf.attributes,
      props,
      nodeProps,
      type
    });
    return /* @__PURE__ */ React4.createElement(Leaf, __spreadValues({}, nodeProps), children);
  }
  return children;
};

// src/utils/pipeRenderLeaf.tsx
var pipeRenderLeaf = (editor, renderLeafProp) => {
  const renderLeafs = [];
  editor.plugins.forEach((plugin) => {
    if (plugin.isLeaf && plugin.key) {
      renderLeafs.push(pluginRenderLeaf(editor, plugin));
    }
  });
  return function render(nodeProps) {
    const props = pipeInjectProps(editor, nodeProps);
    renderLeafs.forEach((renderLeaf) => {
      const newChildren = renderLeaf(props);
      if (newChildren !== void 0) {
        props.children = newChildren;
      }
    });
    if (renderLeafProp) {
      return renderLeafProp(props);
    }
    return /* @__PURE__ */ React5.createElement(DefaultLeaf, __spreadValues({}, props));
  };
};

// src/utils/withHOC.tsx
import React6 from "react";
var withHOC = (HOC, Component, hocProps, hocRef) => React6.forwardRef((props, componentRef) => /* @__PURE__ */ React6.createElement(HOC, __spreadProps(__spreadValues({}, hocProps), { ref: hocRef }), /* @__PURE__ */ React6.createElement(Component, __spreadProps(__spreadValues({}, props), { ref: componentRef }))));

// src/stores/plate-controller/plateControllerStore.ts
import React7 from "react";
import { atom as atom2 } from "jotai";
var {
  plateControllerStore,
  usePlateControllerStore,
  PlateControllerProvider: PlateController
} = createAtomStore(
  {
    activeId: atom2(null),
    primaryEditorIds: atom2([]),
    editorStores: atom2({})
  },
  {
    name: "plateController"
  }
);
var usePlateControllerSelectors = () => usePlateControllerStore().get;
var usePlateControllerActions = () => usePlateControllerStore().set;
var usePlateControllerStates = () => usePlateControllerStore().use;
var usePlateControllerExists = () => !!usePlateControllerStore().store({ warnIfNoStore: false });
var usePlateControllerEditorStore = (idProp) => {
  const storeAtom = React7.useMemo(
    () => atom2((get) => {
      const editorStores = get(plateControllerStore.atom.editorStores);
      const forId = (id) => {
        var _a;
        if (!id)
          return null;
        return (_a = editorStores[id]) != null ? _a : null;
      };
      if (idProp)
        return forId(idProp);
      const lookupOrder = [
        get(plateControllerStore.atom.activeId),
        ...get(plateControllerStore.atom.primaryEditorIds)
      ];
      for (const id of lookupOrder) {
        const store = forId(id);
        if (store)
          return store;
      }
      return null;
    }),
    [idProp]
  );
  return usePlateControllerSelectors().atom(storeAtom);
};

// src/stores/plate/createPlateStore.ts
var PLATE_SCOPE = "plate";
var GLOBAL_PLATE_SCOPE = Symbol("global-plate");
var createPlateStore = (_a = {}) => {
  var _b = _a, {
    decorate = null,
    editor = createPlateFallbackEditor(),
    id,
    isMounted = false,
    versionDecorate = 1,
    versionEditor = 1,
    versionSelection = 1,
    onChange = null,
    editorRef = null,
    plugins = [],
    rawPlugins = [],
    readOnly = null,
    primary = true,
    renderElement = null,
    renderLeaf = null,
    value = null
  } = _b, state = __objRest(_b, [
    "decorate",
    "editor",
    "id",
    "isMounted",
    "versionDecorate",
    "versionEditor",
    "versionSelection",
    "onChange",
    "editorRef",
    "plugins",
    "rawPlugins",
    "readOnly",
    "primary",
    "renderElement",
    "renderLeaf",
    "value"
  ]);
  return createAtomStore(
    __spreadValues({
      decorate,
      editor,
      id,
      isMounted,
      versionDecorate,
      versionEditor,
      versionSelection,
      onChange,
      editorRef,
      plugins,
      rawPlugins,
      readOnly,
      primary,
      renderElement,
      renderLeaf,
      value
    }, state),
    {
      name: "plate",
      extend: (atoms) => ({
        trackedEditor: atom3((get) => ({
          editor: get(atoms.editor),
          version: get(atoms.versionEditor)
        })),
        trackedSelection: atom3((get) => ({
          selection: get(atoms.editor).selection,
          version: get(atoms.versionSelection)
        }))
      })
    }
  );
};
var {
  plateStore,
  usePlateStore,
  PlateProvider: PlateStoreProvider
} = createPlateStore();
var usePlateEditorStore = (id, { debugHookName = "usePlateEditorStore" } = {}) => {
  var _a;
  const localStore = (_a = usePlateStore(id).store({ warnIfNoStore: false })) != null ? _a : null;
  const [localStoreExists] = React8.useState(!!localStore);
  const store = localStoreExists ? localStore : (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    usePlateControllerEditorStore(id)
  );
  const plateControllerExists = usePlateControllerExists();
  const fallbackStore = React8.useMemo(() => createStore(), []);
  if (!store) {
    if (plateControllerExists) {
      return fallbackStore;
    }
    throw new Error(
      `${debugHookName} must be used inside a Plate or PlateController`
    );
  }
  return store;
};
var usePlateSelectors = (id, options) => {
  const store = usePlateEditorStore(id, __spreadValues({
    debugHookName: "usePlateSelectors"
  }, options));
  return usePlateStore({ store }).get;
};
var usePlateActions = (id, options) => {
  const store = usePlateEditorStore(id, __spreadValues({
    debugHookName: "usePlateActions"
  }, options));
  return usePlateStore({ store }).set;
};
var usePlateStates = (id, options) => {
  const store = usePlateEditorStore(id, __spreadValues({
    debugHookName: "usePlateStates"
  }, options));
  return usePlateStore({ store }).use;
};
var usePlateId = () => usePlateSelectors(void 0, { debugHookName: "usePlateId" }).id();

// src/stores/plate/actions/useIncrementVersion.ts
import React9 from "react";
var useIncrementVersion = (key, id, options = {}) => {
  const previousVersionRef = React9.useRef(1);
  const set = usePlateActions(id, __spreadValues({
    debugHookName: "useIncrementVersion"
  }, options))[key]();
  return React9.useCallback(() => {
    const nextVersion = previousVersionRef.current + 1;
    set(nextVersion);
    previousVersionRef.current = nextVersion;
  }, [set]);
};

// src/stores/plate/actions/useRedecorate.ts
import React10 from "react";
var useRedecorate = (id, options = {}) => {
  const updateDecorate = useIncrementVersion("versionDecorate", id, __spreadValues({
    debugHookName: "useRedecorate"
  }, options));
  return React10.useCallback(() => {
    updateDecorate();
  }, [updateDecorate]);
};

// src/stores/plate/actions/useReplaceEditor.ts
import React12 from "react";

// src/stores/plate/selectors/useEditorMounted.ts
var useEditorMounted = (id, options = {}) => {
  return !!usePlateSelectors(id, __spreadValues({
    debugHookName: "useEditorMounted"
  }, options)).isMounted();
};

// src/stores/plate/selectors/useEditorReadOnly.ts
var useEditorReadOnly = (id, options = {}) => {
  return !!usePlateSelectors(id, __spreadValues({
    debugHookName: "useEditorReadOnly"
  }, options)).readOnly();
};

// src/stores/plate/selectors/useEditorRef.ts
var useEditorRef = (id, options = {}) => usePlateSelectors(id, __spreadValues({
  debugHookName: "useEditorRef"
}, options)).editor();

// src/stores/plate/selectors/useEditorSelection.ts
var useEditorSelection = (id, options = {}) => usePlateSelectors(id, __spreadValues({
  debugHookName: "useEditorSelection"
}, options)).trackedSelection().selection;

// src/stores/plate/selectors/useEditorSelector.ts
import React11 from "react";
import { selectAtom } from "jotai/utils";
var useEditorSelector = (selector, deps, _a = {}) => {
  var _b = _a, {
    id,
    equalityFn = (a, b) => a === b
  } = _b, storeOptions = __objRest(_b, [
    "id",
    "equalityFn"
  ]);
  const selectorAtom = React11.useMemo(
    () => selectAtom(
      plateStore.atom.trackedEditor,
      ({ editor }, prev) => selector(editor, prev),
      equalityFn
    ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  return usePlateSelectors(id, __spreadValues({
    debugHookName: "useEditorSelector"
  }, storeOptions)).atom(selectorAtom);
};

// src/stores/plate/selectors/useEditorState.ts
var useEditorState = (id, options = {}) => {
  return usePlateSelectors(id, __spreadValues({
    debugHookName: "useEditorState"
  }, options)).trackedEditor().editor;
};

// src/stores/plate/selectors/useEditorVersion.ts
var useEditorVersion = (id, options = {}) => {
  return usePlateSelectors(id, __spreadValues({
    debugHookName: "useEditorVersion"
  }, options)).versionEditor();
};

// src/stores/plate/selectors/useSelectionVersion.ts
var useSelectionVersion = (id, options = {}) => {
  return usePlateSelectors(id, __spreadValues({
    debugHookName: "useSelectionVersion"
  }, options)).versionSelection();
};

// src/stores/plate/actions/useReplaceEditor.ts
var useReplaceEditor = (id, options = {}) => {
  const editor = useEditorRef(id, __spreadValues({
    debugHookName: "useReplaceEditor"
  }, options));
  const setEditor = usePlateActions(id, __spreadValues({
    debugHookName: "useReplaceEditor"
  }, options)).editor();
  return React12.useCallback(() => {
    const newEditor = createPlateEditor({
      id: editor.id,
      plugins: editor.plugins,
      // disable core plugins as it's already included
      disableCorePlugins: true
    });
    setEditor(newEditor);
  }, [editor, setEditor]);
};

// src/stores/event-editor/selectors/getEventPlateId.ts
var getEventPlateId = (id) => {
  var _a;
  if (id)
    return id;
  const focus = eventEditorSelectors.focus();
  if (focus)
    return focus;
  const blur = eventEditorSelectors.blur();
  if (blur)
    return blur;
  return (_a = eventEditorSelectors.last()) != null ? _a : PLATE_SCOPE;
};

// src/stores/event-editor/selectors/useEventPlateId.ts
var useEventPlateId = (id) => {
  var _a;
  const focus = useEventEditorSelectors.focus();
  const blur = useEventEditorSelectors.blur();
  const last = useEventEditorSelectors.last();
  const providerId = usePlateSelectors().id();
  if (id)
    return id;
  if (focus)
    return focus;
  if (blur)
    return blur;
  return (_a = last != null ? last : providerId) != null ? _a : PLATE_SCOPE;
};

// src/types/PlateStore.ts
var EXPOSED_STORE_KEYS = [
  "readOnly",
  "plugins",
  "onChange",
  "decorate",
  "renderElement",
  "renderLeaf"
];

// src/components/EditorMethodsEffect.ts
var EditorMethodsEffect = ({ id }) => {
  const editor = useEditorRef(id);
  const redecorate = useRedecorate(id);
  const plateStore2 = usePlateStore(id);
  const storeSetters = Object.fromEntries(
    EXPOSED_STORE_KEYS.map((key) => [key, plateStore2.set[key]()])
  );
  const memorizedStoreSetters = React13.useMemo(() => storeSetters, []);
  React13.useEffect(() => {
    editor.redecorate = redecorate;
    editor.plate = {
      set: memorizedStoreSetters
    };
  }, [editor, redecorate, memorizedStoreSetters]);
  return null;
};

// src/components/EditorRefEffect.tsx
import React14 from "react";
function EditorRefPluginEffect({
  id,
  plugin
}) {
  var _a;
  const editor = useEditorRef(id);
  (_a = plugin.useHooks) == null ? void 0 : _a.call(plugin, editor, plugin);
  return null;
}
function EditorRefEffect({ id }) {
  const setIsMounted = usePlateActions(id).isMounted();
  const plugins = usePlateSelectors(id).plugins();
  const editorState = useEditorRef(id);
  const editorRef = usePlateSelectors(id).editorRef();
  React14.useEffect(() => {
    setIsMounted(true);
    return () => {
      setIsMounted(false);
    };
  }, [setIsMounted]);
  React14.useEffect(() => {
    if (typeof editorRef === "function") {
      editorRef(editorState);
      return () => editorRef(null);
    }
    if (editorRef) {
      editorRef.current = editorState;
      return () => {
        editorRef.current = null;
      };
    }
  }, [editorRef, editorState]);
  return /* @__PURE__ */ React14.createElement(React14.Fragment, null, plugins.map((plugin) => /* @__PURE__ */ React14.createElement(EditorRefPluginEffect, { key: plugin.key, id, plugin })));
}

// src/components/EditorStateEffect.tsx
import React15 from "react";
import { Range } from "slate";
import { useSlate } from "slate-react";
var EditorStateEffect = React15.memo(({ id }) => {
  const editorState = useSlate();
  const updateVersionEditor = useIncrementVersion("versionEditor", id);
  React15.useEffect(() => {
    updateVersionEditor();
  });
  const updateVersionSelection = useIncrementVersion("versionSelection", id);
  const prevSelectionRef = React15.useRef(editorState.selection);
  const sameSelection = isSelectionEqual(
    prevSelectionRef.current,
    editorState.selection
  );
  React15.useEffect(() => {
    if (!sameSelection) {
      updateVersionSelection();
    }
    prevSelectionRef.current = editorState.selection;
  }, [editorState.selection, sameSelection, updateVersionSelection]);
  return null;
});
var isSelectionEqual = (a, b) => {
  if (!a && !b)
    return true;
  if (!a || !b)
    return false;
  return Range.equals(a, b);
};

// src/components/Plate.tsx
import React20 from "react";
import { normalizeEditor as normalizeEditor2 } from "@udecode/slate";
import { nanoid as nanoid2 } from "nanoid/non-secure";

// src/components/PlateEffects.tsx
import React19 from "react";

// src/hooks/useEditableProps.ts
import React16 from "react";
import { isDefined as isDefined4 } from "@udecode/utils";
import omit from "lodash/omit.js";
import { useDeepCompareMemo } from "use-deep-compare";

// src/types/misc/dom-attributes.ts
var DOM_HANDLERS = [
  // Clipboard Events
  "onCopy",
  "onCopyCapture",
  "onCut",
  "onCutCapture",
  "onPaste",
  "onPasteCapture",
  // Composition Events
  "onCompositionEnd",
  "onCompositionEndCapture",
  "onCompositionStart",
  "onCompositionStartCapture",
  "onCompositionUpdate",
  "onCompositionUpdateCapture",
  // Focus Events
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  // Form Events
  "onDOMBeforeInput",
  "onBeforeInput",
  "onBeforeInputCapture",
  "onInput",
  "onInputCapture",
  "onReset",
  "onResetCapture",
  "onSubmit",
  "onSubmitCapture",
  "onInvalid",
  "onInvalidCapture",
  // Image Events
  "onLoad",
  "onLoadCapture",
  // Keyboard Events
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyPressCapture",
  "onKeyUp",
  "onKeyUpCapture",
  // Media Events
  "onAbort",
  "onAbortCapture",
  "onCanPlay",
  "onCanPlayCapture",
  "onCanPlayThrough",
  "onCanPlayThroughCapture",
  "onDurationChange",
  "onDurationChangeCapture",
  "onEmptied",
  "onEmptiedCapture",
  "onEncrypted",
  "onEncryptedCapture",
  "onEnded",
  "onEndedCapture",
  "onLoadedData",
  "onLoadedDataCapture",
  "onLoadedMetadata",
  "onLoadedMetadataCapture",
  "onLoadStart",
  "onLoadStartCapture",
  "onPause",
  "onPauseCapture",
  "onPlay",
  "onPlayCapture",
  "onPlaying",
  "onPlayingCapture",
  "onProgress",
  "onProgressCapture",
  "onRateChange",
  "onRateChangeCapture",
  "onSeeked",
  "onSeekedCapture",
  "onSeeking",
  "onSeekingCapture",
  "onStalled",
  "onStalledCapture",
  "onSuspend",
  "onSuspendCapture",
  "onTimeUpdate",
  "onTimeUpdateCapture",
  "onVolumeChange",
  "onVolumeChangeCapture",
  "onWaiting",
  "onWaitingCapture",
  // MouseEvents
  "onAuxClick",
  "onAuxClickCapture",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onContextMenuCapture",
  "onDoubleClick",
  "onDoubleClickCapture",
  "onDrag",
  "onDragCapture",
  "onDragEnd",
  "onDragEndCapture",
  "onDragEnter",
  "onDragEnterCapture",
  "onDragExit",
  "onDragExitCapture",
  "onDragLeave",
  "onDragLeaveCapture",
  "onDragOver",
  "onDragOverCapture",
  "onDragStart",
  "onDragStartCapture",
  "onDrop",
  "onDropCapture",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseMoveCapture",
  "onMouseOut",
  "onMouseOutCapture",
  "onMouseOver",
  "onMouseOverCapture",
  "onMouseUp",
  "onMouseUpCapture",
  // Selection Events
  "onSelect",
  "onSelectCapture",
  // Touch Events
  "onTouchCancel",
  "onTouchCancelCapture",
  "onTouchEnd",
  "onTouchEndCapture",
  "onTouchMove",
  "onTouchMoveCapture",
  "onTouchStart",
  "onTouchStartCapture",
  // Pointer Events
  "onPointerDown",
  "onPointerDownCapture",
  "onPointerMove",
  "onPointerMoveCapture",
  "onPointerUp",
  "onPointerUpCapture",
  "onPointerCancel",
  "onPointerCancelCapture",
  "onPointerEnter",
  "onPointerEnterCapture",
  "onPointerLeave",
  "onPointerLeaveCapture",
  "onPointerOver",
  "onPointerOverCapture",
  "onPointerOut",
  "onPointerOutCapture",
  "onGotPointerCapture",
  "onGotPointerCaptureCapture",
  "onLostPointerCapture",
  "onLostPointerCaptureCapture",
  // UI Events
  "onScroll",
  "onScrollCapture",
  // Wheel Events
  "onWheel",
  "onWheelCapture",
  // Animation Events
  "onAnimationStart",
  "onAnimationStartCapture",
  "onAnimationEnd",
  "onAnimationEndCapture",
  "onAnimationIteration",
  "onAnimationIterationCapture",
  // Transition Events
  "onTransitionEnd",
  "onTransitionEndCapture"
];

// src/hooks/useEditableProps.ts
var useEditableProps = (editableProps = {}) => {
  const { id } = editableProps;
  const editor = useEditorRef(id);
  const selectors = usePlateSelectors(id);
  const versionDecorate = selectors.versionDecorate();
  const readOnly = selectors.readOnly();
  const storeDecorate = selectors.decorate();
  const storeRenderLeaf = selectors.renderLeaf();
  const storeRenderElement = selectors.renderElement();
  const decorateMemo = React16.useMemo(() => {
    return pipeDecorate(editor, storeDecorate != null ? storeDecorate : editableProps == null ? void 0 : editableProps.decorate);
  }, [editableProps == null ? void 0 : editableProps.decorate, editor, storeDecorate]);
  const decorate = React16.useMemo(() => {
    if (!versionDecorate || !decorateMemo)
      return;
    return (entry) => decorateMemo(entry);
  }, [decorateMemo, versionDecorate]);
  const renderElement = React16.useMemo(() => {
    return pipeRenderElement(
      editor,
      storeRenderElement != null ? storeRenderElement : editableProps == null ? void 0 : editableProps.renderElement
    );
  }, [editableProps == null ? void 0 : editableProps.renderElement, editor, storeRenderElement]);
  const renderLeaf = React16.useMemo(() => {
    return pipeRenderLeaf(editor, storeRenderLeaf != null ? storeRenderLeaf : editableProps == null ? void 0 : editableProps.renderLeaf);
  }, [editableProps == null ? void 0 : editableProps.renderLeaf, editor, storeRenderLeaf]);
  const props = useDeepCompareMemo(() => {
    const _props = {
      decorate,
      renderElement,
      renderLeaf
    };
    if (isDefined4(readOnly)) {
      _props.readOnly = readOnly;
    }
    DOM_HANDLERS.forEach((handlerKey) => {
      const handler = pipeHandler(editor, {
        editableProps,
        handlerKey
      });
      if (handler) {
        _props[handlerKey] = handler;
      }
    });
    return _props;
  }, [decorate, editableProps, renderElement, renderLeaf, readOnly]);
  return useDeepCompareMemo(
    () => __spreadValues(__spreadValues({}, omit(editableProps, [...DOM_HANDLERS, "renderElement", "renderLeaf"])), props),
    [editableProps, props]
  );
};

// src/hooks/usePlateEffects.ts
import React17 from "react";
import { isDefined as isDefined5 } from "@udecode/utils";
var usePlateEffects = ({
  id,
  disableCorePlugins,
  plugins: pluginsProp
}) => {
  const editor = useEditorRef(id);
  const states = usePlateStates(id);
  const [rawPlugins, setRawPlugins] = states.rawPlugins();
  const [, setPlugins] = states.plugins();
  React17.useEffect(() => {
    if (isDefined5(pluginsProp) && pluginsProp !== rawPlugins) {
      setRawPlugins(rawPlugins);
      setPlatePlugins(editor, {
        plugins: pluginsProp,
        disableCorePlugins
      });
      setPlugins(editor.plugins);
    }
  }, [
    disableCorePlugins,
    editor,
    rawPlugins,
    pluginsProp,
    setPlugins,
    setRawPlugins
  ]);
};

// src/hooks/useSlateProps.ts
import React18 from "react";
var useSlateProps = ({
  id
}) => {
  const editor = useEditorRef(id);
  const value = usePlateSelectors(id).value();
  const setValue = usePlateActions(id).value();
  const onChangeProp = usePlateSelectors(id).onChange();
  const onChange = React18.useCallback(
    (newValue) => {
      const eventIsHandled = pipeOnChange(editor)(newValue);
      if (!eventIsHandled) {
        onChangeProp == null ? void 0 : onChangeProp(newValue);
      }
      setValue(newValue);
    },
    [editor, setValue, onChangeProp]
  );
  return React18.useMemo(() => {
    return {
      key: editor.key,
      editor,
      onChange,
      value,
      initialValue: value
    };
  }, [editor, onChange, value]);
};

// src/components/PlateEffects.tsx
function PlateEffects(_a) {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  usePlateEffects(props);
  return /* @__PURE__ */ React19.createElement(React19.Fragment, null, children);
}

// src/components/Plate.tsx
function PlateInner({
  normalizeInitialValue: shouldNormalizeInitialValue,
  id: idProp,
  editor: editorProp,
  initialValue,
  value: valueProp,
  children,
  plugins: pluginsProp,
  disableCorePlugins,
  onChange,
  editorRef,
  decorate,
  renderElement,
  renderLeaf,
  readOnly,
  primary,
  maxLength
}) {
  const [id] = React20.useState(() => {
    var _a, _b;
    return (_b = (_a = editorProp == null ? void 0 : editorProp.id) != null ? _a : idProp) != null ? _b : nanoid2();
  });
  const editor = React20.useMemo(
    () => editorProp != null ? editorProp : createPlateEditor({
      id,
      plugins: pluginsProp,
      disableCorePlugins,
      maxLength
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  const value = React20.useMemo(
    () => {
      let currValue = initialValue != null ? initialValue : valueProp;
      if (!currValue) {
        currValue = editor.children.length > 0 ? editor.children : editor.childrenFactory();
      }
      const normalizedValue = normalizeInitialValue(editor, currValue);
      if (normalizedValue) {
        currValue = normalizedValue;
      }
      editor.children = currValue;
      if (shouldNormalizeInitialValue) {
        normalizeEditor2(editor, { force: true });
      }
      return editor.children;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  return /* @__PURE__ */ React20.createElement(
    PlateStoreProvider,
    {
      id,
      editor,
      plugins: editor.plugins,
      rawPlugins: pluginsProp,
      readOnly,
      primary,
      value,
      decorate,
      onChange,
      editorRef,
      renderElement,
      renderLeaf,
      scope: id
    },
    /* @__PURE__ */ React20.createElement(
      PlateEffects,
      {
        id,
        disableCorePlugins,
        plugins: pluginsProp
      },
      children
    )
  );
}
function Plate(props) {
  const { id } = props;
  return /* @__PURE__ */ React20.createElement(PlateInner, __spreadValues({ key: id == null ? void 0 : id.toString() }, props));
}

// src/components/PlateContent.tsx
import React23 from "react";
import { Editable } from "slate-react";

// src/components/PlateControllerEffect.ts
import React21 from "react";
import { focusAtom } from "jotai-optics";
import { useFocused } from "slate-react";
var PlateControllerEffect = ({
  id: idProp
}) => {
  const idFromStore = usePlateId();
  const id = idProp != null ? idProp : idFromStore;
  const currentStoreAtom = React21.useMemo(
    () => focusAtom(
      plateControllerStore.atom.editorStores,
      (optic) => optic.prop(id)
    ),
    [id]
  );
  const setCurrentStore = usePlateControllerActions().atom(currentStoreAtom, {
    warnIfNoStore: false
  });
  const store = usePlateStore(id).store();
  const primary = usePlateSelectors(id).primary();
  const setPrimaryEditorIds = usePlateControllerActions().primaryEditorIds({
    warnIfNoStore: false
  });
  const focused = useFocused();
  const setActiveId = usePlateControllerActions().activeId({
    warnIfNoStore: false
  });
  React21.useEffect(() => {
    setCurrentStore(store != null ? store : null);
    return () => {
      setCurrentStore(null);
      setActiveId((activeId) => activeId === id ? null : activeId);
    };
  }, [store, setCurrentStore, setActiveId, id]);
  React21.useEffect(() => {
    if (primary) {
      setPrimaryEditorIds((ids) => [...ids, id]);
      return () => {
        setPrimaryEditorIds((ids) => ids.filter((i) => i !== id));
      };
    }
  }, [id, primary, setPrimaryEditorIds]);
  React21.useEffect(() => {
    if (id && focused) {
      setActiveId(id);
    }
  }, [id, focused, setActiveId]);
  return null;
};

// src/components/PlateSlate.tsx
import React22 from "react";
import { Slate } from "slate-react";
function PlateSlate({
  id,
  children
}) {
  var _a;
  const slateProps = useSlateProps({ id });
  const editor = useEditorRef(id);
  let aboveSlate = /* @__PURE__ */ React22.createElement(Slate, __spreadValues({}, slateProps), children);
  (_a = editor.plugins) == null ? void 0 : _a.forEach((plugin) => {
    const { renderAboveSlate: RenderAboveSlate } = plugin;
    if (RenderAboveSlate)
      aboveSlate = /* @__PURE__ */ React22.createElement(RenderAboveSlate, null, aboveSlate);
  });
  return aboveSlate;
}

// src/components/PlateContent.tsx
var PlateContent = React23.forwardRef(
  (_a, ref) => {
    var _b = _a, { renderEditable } = _b, props = __objRest(_b, ["renderEditable"]);
    const { id } = props;
    const editor = useEditorRef(id);
    if (!editor) {
      throw new Error(
        "Editor not found. Please ensure that PlateContent is rendered below Plate."
      );
    }
    const editableProps = useEditableProps(props);
    const editable = /* @__PURE__ */ React23.createElement(Editable, __spreadValues({ ref }, editableProps));
    let afterEditable = null;
    let beforeEditable = null;
    editor.plugins.forEach((plugin) => {
      const {
        renderBeforeEditable: RenderBeforeEditable,
        renderAfterEditable: RenderAfterEditable
      } = plugin;
      if (RenderAfterEditable) {
        afterEditable = /* @__PURE__ */ React23.createElement(React23.Fragment, null, afterEditable, /* @__PURE__ */ React23.createElement(RenderAfterEditable, __spreadValues({}, editableProps)));
      }
      if (RenderBeforeEditable) {
        beforeEditable = /* @__PURE__ */ React23.createElement(React23.Fragment, null, beforeEditable, /* @__PURE__ */ React23.createElement(RenderBeforeEditable, __spreadValues({}, editableProps)));
      }
    });
    let aboveEditable = /* @__PURE__ */ React23.createElement(React23.Fragment, null, beforeEditable, renderEditable ? renderEditable(editable) : editable, /* @__PURE__ */ React23.createElement(EditorMethodsEffect, { id }), /* @__PURE__ */ React23.createElement(EditorStateEffect, { id }), /* @__PURE__ */ React23.createElement(EditorRefEffect, { id }), /* @__PURE__ */ React23.createElement(PlateControllerEffect, { id }), afterEditable);
    editor.plugins.forEach((plugin) => {
      const { renderAboveEditable: RenderAboveEditable } = plugin;
      if (RenderAboveEditable)
        aboveEditable = /* @__PURE__ */ React23.createElement(RenderAboveEditable, null, aboveEditable);
    });
    return /* @__PURE__ */ React23.createElement(PlateSlate, { id }, aboveEditable);
  }
);
PlateContent.displayName = "PlateContent";

// src/components/PlateTest.tsx
import React24 from "react";
function PlateTest(_a) {
  var _b = _a, {
    variant = "wordProcessor",
    normalizeInitialValue: normalizeInitialValue2,
    editableProps
  } = _b, props = __objRest(_b, [
    "variant",
    "normalizeInitialValue",
    "editableProps"
  ]);
  const { editor: _editor, id, plugins } = props;
  let editor = _editor;
  if (editor && !editor.plugins) {
    editor = createPlateEditor({
      editor,
      plugins,
      id,
      normalizeInitialValue: normalizeInitialValue2
    });
  }
  return /* @__PURE__ */ React24.createElement(Plate, __spreadProps(__spreadValues({}, props), { editor }), /* @__PURE__ */ React24.createElement(
    PlateContent,
    __spreadValues({
      "data-variant": variant,
      "data-testid": "slate-content-editable",
      autoFocus: true
    }, editableProps)
  ));
}
export {
  CARRIAGE_RETURN,
  DOM_HANDLERS,
  DefaultLeaf,
  ELEMENT_DEFAULT,
  EXPOSED_STORE_KEYS,
  EditorMethodsEffect,
  EditorRefEffect,
  EditorRefPluginEffect,
  EditorStateEffect,
  ElementProvider,
  GLOBAL_PLATE_SCOPE,
  Hotkeys,
  KEY_DESERIALIZE_AST,
  KEY_DESERIALIZE_HTML,
  KEY_EDITOR_PROTOCOL,
  KEY_EVENT_EDITOR,
  KEY_INLINE_VOID,
  KEY_INSERT_DATA,
  KEY_LENGTH,
  KEY_NODE_FACTORY,
  KEY_PREV_SELECTION,
  LINE_FEED,
  NO_BREAK_SPACE,
  PLATE_SCOPE,
  Plate,
  PlateContent,
  PlateController,
  PlateControllerEffect,
  PlateEffects,
  PlateSlate,
  PlateStoreProvider,
  PlateTest,
  SCOPE_ELEMENT,
  SPACE,
  TAB,
  ZERO_WIDTH_SPACE,
  applyDeepToNodes,
  atom,
  cleanHtmlBrElements,
  cleanHtmlCrLf,
  cleanHtmlEmptyElements,
  cleanHtmlFontElements,
  cleanHtmlLinkElements,
  cleanHtmlTextNodes,
  collapseString,
  collapseWhiteSpace,
  collapseWhiteSpaceChildren,
  collapseWhiteSpaceElement,
  collapseWhiteSpaceNode,
  collapseWhiteSpaceText,
  convertDomEventToSyntheticEvent,
  copyBlockMarksToSpanChild,
  createAtomStore,
  createDeserializeAstPlugin,
  createDeserializeHtmlPlugin,
  createEditorProtocolPlugin,
  createEventEditorPlugin,
  createHistoryPlugin,
  createInlineVoidPlugin,
  createInsertDataPlugin,
  createLengthPlugin,
  createNodeFactoryPlugin,
  createPlateEditor,
  createPlateFallbackEditor,
  createPlateStore,
  createPluginFactory,
  createPlugins,
  createPrevSelectionPlugin,
  createReactPlugin,
  createZustandStore,
  deserializeHtml,
  deserializeHtmlElement,
  deserializeHtmlNode,
  deserializeHtmlNodeChildren,
  endInlineFormattingContext,
  eventEditorActions,
  eventEditorSelectors,
  eventEditorStore,
  findHtmlElement,
  flattenDeepPlugins,
  getEventPlateId,
  getHtmlComments,
  getInjectedPlugins,
  getKeyByType,
  getKeysByTypes,
  getPlugin,
  getPluginInjectProps,
  getPluginOptions,
  getPluginType,
  getPluginTypes,
  getPlugins,
  getPluginsByKey,
  getRenderNodeProps,
  getSlateClass,
  htmlBodyToFragment,
  htmlBrToNewLine,
  htmlElementToElement,
  htmlElementToLeaf,
  htmlStringToDOMNode,
  htmlTextNodeToString,
  inferWhiteSpaceRule,
  inlineTagNames,
  isEventHandled,
  isHotkey,
  isHotkeyPressed,
  isHtmlBlockElement,
  isHtmlComment,
  isHtmlElement,
  isHtmlFragmentHref,
  isHtmlInlineElement,
  isHtmlTable,
  isHtmlText,
  isLastNonEmptyTextOfInlineFormattingContext,
  isOlSymbol,
  mapInjectPropsToPlugin,
  mergeDeepPlugins,
  mergeDeepToNodes,
  mockPlugin,
  nanoid,
  normalizeDescendantsToDocumentFragment,
  normalizeInitialValue,
  overridePluginsByKey,
  parseHtmlDocument,
  parseHtmlElement,
  pipeDecorate,
  pipeDeserializeHtmlElement,
  pipeDeserializeHtmlLeaf,
  pipeHandler,
  pipeInjectProps,
  pipeInsertDataQuery,
  pipeInsertFragment,
  pipeOnChange,
  pipeRenderElement,
  pipeRenderLeaf,
  pipeTransformData,
  pipeTransformFragment,
  plateControllerStore,
  plateStore,
  pluginDeserializeHtml,
  pluginInjectProps,
  pluginRenderElement,
  pluginRenderLeaf,
  postCleanHtml,
  preCleanHtml,
  removeHtmlNodesBetweenComments,
  removeHtmlSurroundings,
  replaceTagName,
  resetEditor,
  resetEditorChildren,
  setDefaultPlugin,
  setPlatePlugins,
  someHtmlElement,
  toggleNodeType,
  traverseHtmlComments,
  traverseHtmlElements,
  traverseHtmlNode,
  traverseHtmlTexts,
  unwrapHtmlElement,
  upsertInlineFormattingContext,
  useEditableProps,
  useEditorMounted,
  useEditorReadOnly,
  useEditorRef,
  useEditorSelection,
  useEditorSelector,
  useEditorState,
  useEditorVersion,
  useElement,
  useElementStore,
  useEventEditorSelectors,
  useEventPlateId,
  useHotkeys,
  useIncrementVersion,
  usePlateActions,
  usePlateControllerActions,
  usePlateControllerEditorStore,
  usePlateControllerExists,
  usePlateControllerSelectors,
  usePlateControllerStates,
  usePlateControllerStore,
  usePlateEditorStore,
  usePlateEffects,
  usePlateId,
  usePlateSelectors,
  usePlateStates,
  usePlateStore,
  useRedecorate,
  useReplaceEditor,
  useSelectionVersion,
  useSlateProps,
  withEditorProtocol,
  withHOC,
  withInlineVoid,
  withInsertData,
  withLength,
  withPlate,
  withTHistory,
  withTReact
};
//# sourceMappingURL=index.mjs.map