import * as React$1 from 'react';
import React__default from 'react';
import * as _udecode_slate from '@udecode/slate';
import { TElement, Value, ENodeEntry, EElement, EText, EElementOrText, TNodeEntry, TEditor, THistoryEditor, TRange, TText, TDescendant, EDescendant, GetNodeEntriesOptions, TNode, NodeOf, QueryNodeOptions } from '@udecode/slate';
import * as _udecode_slate_react from '@udecode/slate-react';
import { RenderLeafFn, TReactEditor, TRenderLeafProps, SlateProps } from '@udecode/slate-react';
import * as _udecode_utils from '@udecode/utils';
import { AnyObject, WithRequired } from '@udecode/utils';
import * as slate from 'slate';
import { Range, Path } from 'slate';
import * as jotai_x from 'jotai-x';
import { JotaiStore } from 'jotai-x';
export { createAtomStore } from 'jotai-x';
import * as jotai from 'jotai';
import { Atom } from 'jotai';
export { atom } from 'jotai';
import * as slate_react from 'slate-react';
import { RenderElementProps } from 'slate-react';
import * as slate_react_dist_components_editable from 'slate-react/dist/components/editable';
import { EditableProps } from 'slate-react/dist/components/editable';
export { nanoid } from 'nanoid';
export { Options as UseHotkeysOptions, isHotkeyPressed, useHotkeys } from 'react-hotkeys-hook';
import * as zustand_x from 'zustand-x';
export { StateActions as ZustandStateActions, StoreApi as ZustandStoreApi, createZustandStore } from 'zustand-x';
import * as slate_history from 'slate-history';
import { ReplaceNodeChildrenOptions } from '@udecode/slate-utils';
export { isHotkey } from 'is-hotkey';

/**
 * Get the element by plugin key.
 * If no element is found in the context, it will return an empty object.
 */
declare const useElement: <T extends TElement = TElement>(pluginKey?: string) => T;

declare const SCOPE_ELEMENT = "element";
type ElementStoreState = {
    element: TElement;
};
declare const useElementStore: jotai_x.UseStoreApi<ElementStoreState, object>;
declare const ElementProvider: React$1.FC<jotai_x.ProviderProps<{
    element: TElement;
}>>;

/**
 * A unique id used as a provider scope.
 * Use it if you have multiple `Plate` in the same React tree.
 * @default PLATE_SCOPE
 */
type PlateId = string;
declare const PLATE_SCOPE = "plate";
declare const GLOBAL_PLATE_SCOPE: unique symbol;
declare const createPlateStore: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>({ decorate, editor, id, isMounted, versionDecorate, versionEditor, versionSelection, onChange, editorRef, plugins, rawPlugins, readOnly, primary, renderElement, renderLeaf, value, ...state }?: Partial<PlateStoreState<V, E>>) => jotai_x.AtomStoreApi<PlateStoreState<V, E>, {
    trackedEditor: jotai.Atom<{
        editor: any;
        version: number | null;
    }>;
    trackedSelection: jotai.Atom<{
        selection: any;
        version: number | null;
    }>;
}, "plate">;
declare const plateStore: jotai_x.StoreApi<PlateStoreState<Value, PlateEditor<Value>>, {
    trackedEditor: jotai.Atom<{
        editor: any;
        version: number | null;
    }>;
    trackedSelection: jotai.Atom<{
        selection: any;
        version: number | null;
    }>;
}, "plate">;
declare const usePlateStore: jotai_x.UseStoreApi<PlateStoreState<Value, PlateEditor<Value>>, {
    trackedEditor: jotai.Atom<{
        editor: any;
        version: number | null;
    }>;
    trackedSelection: jotai.Atom<{
        selection: any;
        version: number | null;
    }>;
}>;
declare const PlateStoreProvider: React__default.FC<jotai_x.ProviderProps<{
    id: string;
    editor: PlateEditor<Value>;
    rawPlugins: PlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[];
    plugins: WithPlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[];
    value: Value;
    isMounted: boolean | null;
    readOnly: boolean | null;
    primary: boolean | null;
    versionEditor: number | null;
    versionSelection: number | null;
    versionDecorate: number | null;
    onChange: ((value: Value) => void) | null;
    editorRef: React__default.ForwardedRef<PlateEditor<Value>>;
    decorate: ((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | null;
    renderElement: RenderElementFn | null;
    renderLeaf: _udecode_slate_react.RenderLeafFn | null;
}>>;
interface UsePlateEditorStoreOptions {
    debugHookName?: string;
}
declare const usePlateEditorStore: (id?: PlateId, { debugHookName }?: UsePlateEditorStoreOptions) => JotaiStore;
declare const usePlateSelectors: (id?: PlateId, options?: UsePlateEditorStoreOptions) => {
    id: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string;
    editor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => PlateEditor<Value>;
    rawPlugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => PlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[];
    plugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => WithPlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[];
    value: (options?: (string | jotai_x.UseAtomOptions) | undefined) => Value;
    isMounted: (options?: (string | jotai_x.UseAtomOptions) | undefined) => boolean | null;
    readOnly: (options?: (string | jotai_x.UseAtomOptions) | undefined) => boolean | null;
    primary: (options?: (string | jotai_x.UseAtomOptions) | undefined) => boolean | null;
    versionEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => number | null;
    versionSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => number | null;
    versionDecorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => number | null;
    onChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((value: Value) => void) | null;
    editorRef: (options?: (string | jotai_x.UseAtomOptions) | undefined) => React__default.ForwardedRef<PlateEditor<Value>>;
    decorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => ((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | null;
    renderElement: (options?: (string | jotai_x.UseAtomOptions) | undefined) => RenderElementFn | null;
    renderLeaf: (options?: (string | jotai_x.UseAtomOptions) | undefined) => _udecode_slate_react.RenderLeafFn | null;
    trackedEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => {
        editor: any;
        version: number | null;
    };
    trackedSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => {
        selection: any;
        version: number | null;
    };
} & {
    atom: <V>(atom: jotai.Atom<V>, options?: (string | jotai_x.UseAtomOptions) | undefined) => V;
};
declare const usePlateActions: (id?: PlateId, options?: UsePlateEditorStoreOptions) => {
    id: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string) => void;
    editor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: PlateEditor<Value>) => void;
    rawPlugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: PlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[]) => void;
    plugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: WithPlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[]) => void;
    value: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: Value) => void;
    isMounted: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: boolean | null) => void;
    readOnly: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: boolean | null) => void;
    primary: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: boolean | null) => void;
    versionEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: number | null) => void;
    versionSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: number | null) => void;
    versionDecorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: number | null) => void;
    onChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((value: Value) => void) | null) => void;
    editorRef: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: React__default.ForwardedRef<PlateEditor<Value>>) => void;
    decorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: ((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | null) => void;
    renderElement: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: RenderElementFn | null) => void;
    renderLeaf: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: _udecode_slate_react.RenderLeafFn | null) => void;
    trackedEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: unknown[]) => unknown;
    trackedSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: unknown[]) => unknown;
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: A) => R;
};
declare const usePlateStates: (id?: PlateId, options?: UsePlateEditorStoreOptions) => {
    id: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string, (args_0: string) => void];
    editor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [PlateEditor<Value>, (args_0: PlateEditor<Value>) => void];
    rawPlugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [PlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[], (args_0: PlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[]) => void];
    plugins: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [WithPlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[], (args_0: WithPlatePlugin<_udecode_utils.AnyObject, Value, PlateEditor<Value>>[]) => void];
    value: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [Value, (args_0: Value) => void];
    isMounted: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [boolean | null, (args_0: boolean | null) => void];
    readOnly: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [boolean | null, (args_0: boolean | null) => void];
    primary: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [boolean | null, (args_0: boolean | null) => void];
    versionEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [number | null, (args_0: number | null) => void];
    versionSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [number | null, (args_0: number | null) => void];
    versionDecorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [number | null, (args_0: number | null) => void];
    onChange: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((value: Value) => void) | null, (args_0: ((value: Value) => void) | null) => void];
    editorRef: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [React__default.ForwardedRef<PlateEditor<Value>>, (args_0: React__default.ForwardedRef<PlateEditor<Value>>) => void];
    decorate: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | null, (args_0: ((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | null) => void];
    renderElement: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [RenderElementFn | null, (args_0: RenderElementFn | null) => void];
    renderLeaf: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [_udecode_slate_react.RenderLeafFn | null, (args_0: _udecode_slate_react.RenderLeafFn | null) => void];
    trackedEditor: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [unknown, (...args: unknown[]) => unknown];
    trackedSelection: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [unknown, (...args: unknown[]) => unknown];
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => [V, (...args: A) => R];
};
/**
 * Get the closest `Plate` id.
 */
declare const usePlateId: () => PlateId;

type NoInfer<T> = [T][T extends any ? 0 : never];

type Nullable<T> = {
    [P in keyof T]: T[P] | null;
};

/**
 * If true, the next handlers will be skipped.
 */
type HandlerReturnType = boolean | void;
type DOMHandlerReturnType<EV = {}> = (event: EV) => HandlerReturnType;
type DOMHandler<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>, EV = {}> = (editor: E, plugin: WithPlatePlugin<P, V, E>) => DOMHandlerReturnType<EV>;
interface DOMHandlers<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> {
    onCopy?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onCopyCapture?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onCut?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onCutCapture?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onPaste?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onPasteCapture?: DOMHandler<P, V, E, React__default.ClipboardEvent>;
    onCompositionEnd?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onCompositionEndCapture?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onCompositionStart?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onCompositionStartCapture?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onCompositionUpdate?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onCompositionUpdateCapture?: DOMHandler<P, V, E, React__default.CompositionEvent>;
    onFocus?: DOMHandler<P, V, E, React__default.FocusEvent>;
    onFocusCapture?: DOMHandler<P, V, E, React__default.FocusEvent>;
    onBlur?: DOMHandler<P, V, E, React__default.FocusEvent>;
    onBlurCapture?: DOMHandler<P, V, E, React__default.FocusEvent>;
    onDOMBeforeInput?: DOMHandler<P, V, E, Event>;
    onBeforeInput?: DOMHandler<P, V, E, React__default.FormEvent>;
    onBeforeInputCapture?: DOMHandler<P, V, E, React__default.FormEvent>;
    onInput?: DOMHandler<P, V, E, React__default.FormEvent>;
    onInputCapture?: DOMHandler<P, V, E, React__default.FormEvent>;
    onReset?: DOMHandler<P, V, E, React__default.FormEvent>;
    onResetCapture?: DOMHandler<P, V, E, React__default.FormEvent>;
    onSubmit?: DOMHandler<P, V, E, React__default.FormEvent>;
    onSubmitCapture?: DOMHandler<P, V, E, React__default.FormEvent>;
    onInvalid?: DOMHandler<P, V, E, React__default.FormEvent>;
    onInvalidCapture?: DOMHandler<P, V, E, React__default.FormEvent>;
    onLoad?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onKeyDown?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onKeyDownCapture?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onKeyPress?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onKeyPressCapture?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onKeyUp?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onKeyUpCapture?: DOMHandler<P, V, E, React__default.KeyboardEvent>;
    onAbort?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onAbortCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onCanPlay?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onCanPlayCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onCanPlayThrough?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onCanPlayThroughCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onDurationChange?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onDurationChangeCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEmptied?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEmptiedCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEncrypted?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEncryptedCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEnded?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onEndedCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadedData?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadedDataCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadedMetadata?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadedMetadataCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadStart?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onLoadStartCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPause?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPauseCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPlay?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPlayCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPlaying?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onPlayingCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onProgress?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onProgressCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onRateChange?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onRateChangeCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSeeked?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSeekedCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSeeking?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSeekingCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onStalled?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onStalledCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSuspend?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSuspendCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onTimeUpdate?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onTimeUpdateCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onVolumeChange?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onVolumeChangeCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onWaiting?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onWaitingCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onAuxClick?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onAuxClickCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onClick?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onClickCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onContextMenu?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onContextMenuCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onDoubleClick?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onDoubleClickCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onDrag?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragEnd?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragEndCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragEnter?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragEnterCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragExit?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragExitCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragLeave?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragLeaveCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragOver?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragOverCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragStart?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDragStartCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDrop?: DOMHandler<P, V, E, React__default.DragEvent>;
    onDropCapture?: DOMHandler<P, V, E, React__default.DragEvent>;
    onMouseDown?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseDownCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseEnter?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseLeave?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseMove?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseMoveCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseOut?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseOutCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseOver?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseOverCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseUp?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onMouseUpCapture?: DOMHandler<P, V, E, React__default.MouseEvent>;
    onSelect?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onSelectCapture?: DOMHandler<P, V, E, React__default.SyntheticEvent>;
    onTouchCancel?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchCancelCapture?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchEnd?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchEndCapture?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchMove?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchMoveCapture?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchStart?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onTouchStartCapture?: DOMHandler<P, V, E, React__default.TouchEvent>;
    onPointerDown?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerDownCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerMove?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerMoveCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerUp?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerUpCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerCancel?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerCancelCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerEnter?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerEnterCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerLeave?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerLeaveCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerOver?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerOverCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerOut?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onPointerOutCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onGotPointerCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onGotPointerCaptureCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onLostPointerCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onLostPointerCaptureCapture?: DOMHandler<P, V, E, React__default.PointerEvent>;
    onScroll?: DOMHandler<P, V, E, React__default.UIEvent>;
    onScrollCapture?: DOMHandler<P, V, E, React__default.UIEvent>;
    onWheel?: DOMHandler<P, V, E, React__default.WheelEvent>;
    onWheelCapture?: DOMHandler<P, V, E, React__default.WheelEvent>;
    onAnimationStart?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAnimationStartCapture?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAnimationEnd?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAnimationEndCapture?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAnimationIteration?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onAnimationIterationCapture?: DOMHandler<P, V, E, React__default.AnimationEvent>;
    onTransitionEnd?: DOMHandler<P, V, E, React__default.TransitionEvent>;
    onTransitionEndCapture?: DOMHandler<P, V, E, React__default.TransitionEvent>;
}

type DecorateEntry<V extends Value = Value> = (entry: ENodeEntry<V>) => Range[] | undefined;
/**
 * Property used by Plate to decorate editor ranges.
 * If the function returns undefined then no ranges are modified.
 * If the function returns an array the returned ranges are merged with the ranges called by other plugins.
 */
type Decorate<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = (editor: PlateEditor<V>, plugin: WithPlatePlugin<P, V, E>) => DecorateEntry<V>;

type DeserializeHtml = {
    /**
     * List of HTML attribute names to store their values in `node.attributes`.
     */
    attributeNames?: string[];
    /**
     * Deserialize an element.
     * Use this instead of plugin.isElement if you don't want the plugin to renderElement.
     * @default plugin.isElement
     */
    isElement?: boolean;
    /**
     * Deserialize a leaf.
     * Use this instead of plugin.isLeaf if you don't want the plugin to renderLeaf.
     * @default plugin.isLeaf
     */
    isLeaf?: boolean;
    /**
     * Deserialize html element to slate node.
     */
    getNode?: (element: HTMLElement, node: AnyObject) => AnyObject | undefined | void;
    query?: (element: HTMLElement) => boolean;
    rules?: {
        /**
         * Deserialize an element:
         * - if this option (string) is in the element attribute names.
         * - if this option (object) values match the element attributes.
         */
        validAttribute?: string | {
            [key: string]: string | string[];
        };
        /**
         * Valid element `className`.
         */
        validClassName?: string;
        /**
         * Valid element `nodeName`.
         * Set '*' to allow any node name.
         */
        validNodeName?: string | string[];
        /**
         * Valid element style values.
         * Can be a list of string (only one match is needed).
         */
        validStyle?: Partial<Record<keyof CSSStyleDeclaration, string | string[] | undefined>>;
    }[];
    /**
     * Whether or not to include deserialized children on this node
     */
    withoutChildren?: boolean;
};

type HotkeyPlugin = {
    /**
     * Hotkeys to listen to trigger a plugin action.
     */
    hotkey?: string | string[];
};

type TRenderElementProps<V extends Value = Value, N extends TElement = EElement<V>> = Omit<RenderElementProps, 'element'> & {
    element: N;
};
type RenderElementFn = (props: TRenderElementProps) => React.ReactElement;

/**
 * Element props passed by Plate
 */
type PlateRenderElementProps<V extends Value = Value, N extends TElement = EElement<V>> = PlateRenderNodeProps<V> & TRenderElementProps<V, N>;

interface InjectComponentProps<V extends Value = Value> extends PlateRenderElementProps<V> {
    key: string;
}
type InjectComponentReturnType<V extends Value = Value> = React__default.FC<PlateRenderElementProps<V>> | undefined;
type InjectComponent<V extends Value = Value> = (props: InjectComponentProps<V>) => InjectComponentReturnType;

interface GetInjectPropsOptions<V extends Value = Value> {
    /**
     * Existing className.
     */
    className?: string;
    /**
     * Style value or className key.
     */
    element?: EElement<V>;
    /**
     * Style value or className key.
     */
    text?: EText<V>;
    /**
     * Existing style.
     */
    style?: React__default.CSSProperties;
}
interface GetInjectPropsReturnType extends AnyObject {
    className?: string;
    style?: React__default.CSSProperties;
}
/**
 * Return if `element`, `text`, `nodeKey` is defined.
 * Return if `node.type` is not in `validTypes` (if defined).
 * Return if `value = node[nodeKey]` is not in `validNodeValues` (if defined).
 * If `classNames[value]` is defined, override `className` with it.
 * If `styleKey` is defined, override `style` with `[styleKey]: value`.
 */
declare const pluginInjectProps: <V extends Value>(editor: PlateEditor<V>, { key, inject: { props } }: WithPlatePlugin<{}, V>, nodeProps: GetInjectPropsOptions<V>) => GetInjectPropsReturnType | undefined;

interface TransformOptions<V extends Value = Value> extends GetInjectPropsOptions<V> {
    nodeValue?: any;
    value?: any;
}
interface InjectProps<V extends Value> {
    inject?: {
        /**
         * Properties used by Plate to inject props into any node `component`.
         */
        props?: {
            /**
             * Object whose keys are node values and values are classNames which will be extended.
             */
            classNames?: AnyObject;
            /**
             * Default node value.
             * The node key would be unset if the node value = defaultNodeValue.
             */
            defaultNodeValue?: any;
            /**
             * Node key to map to the styles.
             */
            nodeKey?: string;
            /**
             * Whether to inject the props. If true, overrides all other checks.
             */
            query?: (options: NonNullable<NonNullable<InjectProps<V>['inject']>['props']>, nodeProps: GetInjectPropsOptions<V>) => boolean;
            /**
             * Style key to override.
             * @default nodeKey
             */
            styleKey?: keyof React__default.CSSProperties;
            /**
             * Transform the className.
             * @default clsx(className, classNames[value])
             */
            transformClassName?: (options: TransformOptions<V>) => any;
            /**
             * Transform the node value for the style or className.
             * @default nodeValue
             */
            transformNodeValue?: (options: TransformOptions<V>) => any;
            /**
             * Transform the injected props.
             */
            transformProps?: (options: TransformOptions<V>, props: GetInjectPropsReturnType) => AnyObject | undefined;
            /**
             * Transform the style.
             * @default { ...style, [styleKey]: value }
             */
            transformStyle?: (options: TransformOptions<V>) => React__default.CSSProperties;
            /**
             * List of supported node values.
             */
            validNodeValues?: any[];
            /**
             * Node types required to inject the props.
             * @default [ELEMENT_DEFAULT]
             */
            validTypes?: string[];
        };
    };
}

type KeyboardHandler<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = DOMHandler<P, V, E, React__default.KeyboardEvent>;
type KeyboardHandlerReturnType = DOMHandlerReturnType<React__default.KeyboardEvent>;

/**
 * Function called whenever a change occurs in the editor.
 * Return `false` to prevent calling the next plugin handler.
 * @see {@link SlatePropsOnChange}
 */
type OnChange<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = (editor: E, plugin: WithPlatePlugin<P, V, E>) => (value: V) => HandlerReturnType;

/**
 * The plate plugin component.
 */
type PlatePluginComponent<T = any> = React__default.FC<T>;

type PlatePluginInsertDataOptions = {
    data: string;
    dataTransfer: DataTransfer;
};
type PlatePluginInsertData<V extends Value = Value> = {
    /**
     * Format to get data. Example data types are text/plain and text/uri-list.
     */
    format?: string;
    /**
     * Query to skip this plugin.
     */
    query?: (options: PlatePluginInsertDataOptions) => boolean;
    /**
     * Deserialize data to fragment
     */
    getFragment?: (options: PlatePluginInsertDataOptions) => EElementOrText<V>[] | undefined;
    /**
     * Function called on `editor.insertData` just before `editor.insertFragment`.
     * Default: if the block above the selection is empty and the first fragment node type is not inline,
     * set the selected node type to the first fragment node type.
     * @return if true, the next handlers will be skipped.
     */
    preInsert?: (fragment: EElementOrText<V>[], options: PlatePluginInsertDataOptions) => HandlerReturnType;
    /**
     * Transform the inserted data.
     */
    transformData?: (data: string, options: {
        dataTransfer: DataTransfer;
    }) => string;
    /**
     * Transform the fragment to insert.
     */
    transformFragment?: (fragment: EElementOrText<V>[], options: PlatePluginInsertDataOptions) => EElementOrText<V>[];
};

/**
 * Unique key to store the plugins by key.
 */
type PluginKey = string;
interface PlatePluginKey {
    /**
     * Property used by Plate to store the plugins by key in `editor.pluginsByKey`.
     */
    key?: PluginKey;
}

/**
 * Props object or function returning props object.
 */
type PlatePluginProps<V extends Value = Value> = AnyObject | ((props: PlateRenderElementProps<V> & PlateRenderLeafProps<V>) => AnyObject | undefined);

/**
 * `EditableProps` are passed to the <Editable> component.
 */
type TEditableProps = Omit<EditableProps, 'decorate' | 'renderElement' | 'renderLeaf'> & {
    decorate?: (entry: TNodeEntry) => Range[];
    renderElement?: RenderElementFn;
    renderLeaf?: RenderLeafFn;
};

type RenderAfterEditable = (editableProps: TEditableProps) => React.ReactElement | null;

type SerializeHtml<V extends Value = Value> = React__default.FC<PlateRenderElementProps<V> & PlateRenderLeafProps<V>>;

interface ToggleMarkPlugin extends HotkeyPlugin {
    /**
     * Node properties to delete.
     */
    clear?: string | string[];
}

/**
 * Plate plugin overriding the `editor` methods.
 * Naming convention is `with*`.
 */
type WithOverride<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>, EE extends E = E> = (editor: E, plugin: WithPlatePlugin<P, V, E>) => EE;

declare const DOM_HANDLERS: (keyof DOMHandlers)[];

/**
 * The `PlatePlugin` interface is a base interface for all plugins.
 */
type PlatePlugin<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = Required<PlatePluginKey> & {
    editor?: Nullable<{
        /**
         * Properties used by the `insertData` core plugin to deserialize inserted data to a slate fragment.
         * The fragment will be inserted to the editor if not empty.
         */
        insertData?: PlatePluginInsertData<V>;
    }>;
    /**
     * Handlers called whenever the corresponding event occurs in the editor.
     * Event handlers can return a boolean flag to specify whether the event can be treated as being handled.
     * If it returns `true`, the next handlers will not be called.
     */
    handlers?: Nullable<DOMHandlers<P, V, E> & {
        /**
         * @see {@link OnChange}
         */
        onChange?: OnChange<P, V, E>;
    }>;
    /**
     * Inject into Plate.
     */
    inject?: Nullable<{
        /**
         * Property used by Plate to inject a component above other plugins `component`.
         */
        aboveComponent?: InjectComponent<V>;
        /**
         * Property used by Plate to inject a component below other plugins `component`, i.e. above its `children`.
         */
        belowComponent?: InjectComponent<V>;
        /**
         * Property that can be used by a plugin to allow other plugins to inject code.
         * For example, if multiple plugins have defined
         * `inject.editor.insertData.transformData` for `key=KEY_DESERIALIZE_HTML`,
         * `insertData` plugin will call all of these `transformData` for `KEY_DESERIALIZE_HTML` plugin.
         * Differs from `overrideByKey` as this is not overriding any plugin.
         */
        pluginsByKey?: Record<PluginKey, Partial<PlatePlugin<PluginOptions, V, E>>>;
    }>;
    /**
     * Property used by Plate to render nodes of this `type` as elements, i.e. `renderElement`.
     */
    isElement?: boolean;
    /**
     * Property used by `inlineVoid` core plugin to set elements of this `type` as inline.
     */
    isInline?: boolean;
    /**
     * Property used by `isMarkableVoid` core plugin to set void elements of this `type` as markable.
     */
    isMarkableVoid?: boolean;
    /**
     * Property used by Plate to render nodes of this `type` as leaves, i.e. `renderLeaf`.
     */
    isLeaf?: boolean;
    /**
     * Property used by `inlineVoid` core plugin to set elements of this `type` as void.
     */
    isVoid?: boolean;
    /**
     * Property used by Plate to enable/disable the plugin.
     */
    enabled?: boolean;
    /**
     * Extended properties used by any plugin as options.
     */
    options?: P;
    /**
     * Property used by Plate to render a node by type.
     * It requires slate node properties to have a `type` property.
     * @default key
     */
    type?: string;
} & InjectProps<V> & Nullable<{
    /**
     * React component rendering a slate element or leaf.
     * @default DefaultElement | DefaultLeaf
     */
    component?: PlatePluginComponent;
    /**
     * @see {@link Decorate}
     */
    decorate?: Decorate<P, V, E>;
    /**
     * Properties used by the HTML deserializer core plugin for each HTML element.
     */
    deserializeHtml?: Nullable<DeserializeHtml>;
    /**
     * Normalize initial value before passing it into the editor.
     * @return normalized value
     */
    normalizeInitialValue?: (initialValue: V) => V;
    /**
     * Property used by Plate to deeply override plugins by key.
     */
    overrideByKey?: Record<PluginKey, Partial<PlatePlugin<PluginOptions, V, E>>>;
    /**
     * Recursive plugin support to allow having multiple plugins in a single plugin.
     * Plate eventually flattens all the plugins into the editor.
     */
    plugins?: PlatePlugin<PluginOptions, V, E>[];
    /**
     * Property used by Plate to override node `component` props.
     * If function, its returning value will be shallow merged to the old props, with the old props as parameter.
     * If object, its value will be shallow merged to the old props.
     */
    props?: PlatePluginProps<V>;
    /**
     * Render a component above `Editable`.
     */
    renderAboveEditable?: React__default.FC<{
        children: React__default.ReactNode;
    }>;
    /**
     * Render a component above `Slate`.
     */
    renderAboveSlate?: React__default.FC<{
        children: React__default.ReactNode;
    }>;
    /**
     * Render a component after `Editable`.
     */
    renderAfterEditable?: RenderAfterEditable;
    /**
     * Render a component before `Editable`.
     */
    renderBeforeEditable?: RenderAfterEditable;
    /**
     * Property used by `serializeHtml` util to replace `renderElement` and `renderLeaf` when serializing a node of this `type`.
     */
    serializeHtml?: SerializeHtml<V>;
    /**
     * Recursive plugin merging.
     * Can be used to derive plugin fields from `editor` and `plugin`.
     * The returned value will be deeply merged to the plugin.
     */
    then?: (editor: E, plugin: WithPlatePlugin<P, V, E>) => Partial<PlatePlugin<PluginOptions, V, E>> | undefined | void;
    /**
     * For internal use. Tracks if then has been replaced for recursive calls.
     */
    _thenReplaced?: number;
    /**
     * Hook called when the editor is initialized.
     */
    useHooks?: (editor: E, plugin: WithPlatePlugin<P, V, E>) => void;
    /**
     * Editor method overriders.
     */
    withOverrides?: WithOverride<P, V, E>;
}>;
type PluginOptions = AnyObject;
type WithPlatePlugin<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = WithRequired<PlatePlugin<P, V, E>, 'type' | 'options' | 'inject' | 'editor'>;

type OverrideByKey<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = Record<PluginKey, Partial<PlatePlugin<{}, V, E>>>;

/**
 * Function used to render an element.
 * If the function returns undefined then the next RenderElement function is called.
 * If the function renders a JSX element then that JSX element is rendered.
 */
type RenderElement = <V extends Value>(props: PlateRenderElementProps<V>) => React.ReactElement | undefined;

/**
 * Function used to render the children of a leaf.
 * If the function returns undefined then the next RenderLeaf function is called and the current children are not modified.
 * The children passed to the function may be the result of a previous plugin.
 * To wrap the previous plugin simply return the passed children.
 * You do not need to add the attributes to your return value.
 * The attributes are added by default.
 * RenderLeaf always returns a JSX element (even if unmodified) to support multiple marks on a node.
 */
type RenderLeaf = <V extends Value = Value>(props: PlateRenderLeafProps<V>) => React.ReactElement;

declare const useIncrementVersion: (key: PlateChangeKey, id?: PlateId, options?: UsePlateEditorStoreOptions) => () => void;

declare const useRedecorate: (id?: PlateId, options?: UsePlateEditorStoreOptions) => () => void;

/**
 * Replace plate editor with the same id and plugins.
 * Remounts `PlateContent`.
 */
declare const useReplaceEditor: (id?: PlateId, options?: UsePlateEditorStoreOptions) => () => void;

declare const useEditorMounted: (id?: PlateId, options?: UsePlateEditorStoreOptions) => boolean;

/**
 * Whether the editor is read-only.
 * You can also use `useReadOnly` from `slate-react` in node components.
 */
declare const useEditorReadOnly: (id?: PlateId, options?: UsePlateEditorStoreOptions) => boolean;

/**
 * Get editor ref which is never updated.
 */
declare const useEditorRef: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(id?: PlateId, options?: UsePlateEditorStoreOptions) => E;

/**
 * Get the editor selection (deeply memoized).
 */
declare const useEditorSelection: (id?: PlateId, options?: UsePlateEditorStoreOptions) => any;

interface UseEditorSelectorOptions<T> extends UsePlateEditorStoreOptions {
    id?: PlateId;
    equalityFn?: (a: T, b: T) => boolean;
}
declare const useEditorSelector: <T, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(selector: (editor: E, prev?: T | undefined) => T, deps: React__default.DependencyList, { id, equalityFn, ...storeOptions }?: UseEditorSelectorOptions<T>) => T;

/**
 * Get editor state which is updated on editor change.
 */
declare const useEditorState: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(id?: PlateId, options?: UsePlateEditorStoreOptions) => E;

/**
 * Version incremented on each editor change.
 */
declare const useEditorVersion: (id?: PlateId, options?: UsePlateEditorStoreOptions) => number | null;

/**
 * Version incremented on selection change.
 */
declare const useSelectionVersion: (id?: PlateId, options?: UsePlateEditorStoreOptions) => number | null;

type EventEditorState = {
    /**
     * Last editor id that has been blurred.
     */
    blur: PlateId | null;
    /**
     * Editor id that is currently being focused.
     */
    focus: PlateId | null;
    /**
     * Last editor id.
     */
    last: PlateId | null;
};
/**
 * Store where the keys are event names and the values are editor ids.
 */
declare const eventEditorStore: zustand_x.StoreApi<"event-editor", EventEditorState, zustand_x.StateActions<EventEditorState>, {}>;
declare const eventEditorActions: zustand_x.StateActions<EventEditorState>;
declare const eventEditorSelectors: zustand_x.StoreApiGet<EventEditorState, {}>;
declare const useEventEditorSelectors: zustand_x.GetRecord<EventEditorState>;

declare const getEventPlateId: (id?: PlateId) => string;

/**
 * Get last event editor id: focus, blur or last.
 */
declare const useEventPlateId: (id?: PlateId) => string;

declare const plateControllerStore: jotai_x.StoreApi<{
    activeId: jotai.PrimitiveAtom<string | null> & {
        init: string | null;
    };
    primaryEditorIds: jotai.PrimitiveAtom<string[]> & {
        init: string[];
    };
    editorStores: jotai.PrimitiveAtom<Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null>> & {
        init: Record<string, {
            get: <Value>(atom: Atom<Value>) => Value;
            set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
            sub: (atom: Atom<unknown>, listener: () => void) => () => void;
            dev_subscribe_store: (l: (action: {
                type: "write";
                flushed: Set<Atom<unknown>>;
            } | {
                type: "async-write";
                flushed: Set<Atom<unknown>>;
            } | {
                type: "sub";
                flushed: Set<Atom<unknown>>;
            } | {
                type: "unsub";
            } | {
                type: "restore";
                flushed: Set<Atom<unknown>>;
            }) => void, rev: 2) => () => void;
            dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
            dev_get_atom_state: (a: Atom<unknown>) => ({
                d: Map<Atom<unknown>, any & ({
                    e: unknown;
                } | {
                    v: unknown;
                })>;
            } & ({
                e: unknown;
            } | {
                v: unknown;
            })) | undefined;
            dev_get_mounted: (a: Atom<unknown>) => {
                l: Set<() => void>;
                t: Set<Atom<unknown>>;
                u?: (() => void) | undefined;
            } | undefined;
            dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
        } | {
            get: <Value>(atom: Atom<Value>) => Value;
            set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
            sub: (atom: Atom<unknown>, listener: () => void) => () => void;
            dev_subscribe_store?: undefined;
            dev_get_mounted_atoms?: undefined;
            dev_get_atom_state?: undefined;
            dev_get_mounted?: undefined;
            dev_restore_atoms?: undefined;
        } | null>;
    };
}, object, "plateController">;
declare const usePlateControllerStore: jotai_x.UseStoreApi<{
    activeId: jotai.PrimitiveAtom<string | null> & {
        init: string | null;
    };
    primaryEditorIds: jotai.PrimitiveAtom<string[]> & {
        init: string[];
    };
    editorStores: jotai.PrimitiveAtom<Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null>> & {
        init: Record<string, {
            get: <Value>(atom: Atom<Value>) => Value;
            set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
            sub: (atom: Atom<unknown>, listener: () => void) => () => void;
            dev_subscribe_store: (l: (action: {
                type: "write";
                flushed: Set<Atom<unknown>>;
            } | {
                type: "async-write";
                flushed: Set<Atom<unknown>>;
            } | {
                type: "sub";
                flushed: Set<Atom<unknown>>;
            } | {
                type: "unsub";
            } | {
                type: "restore";
                flushed: Set<Atom<unknown>>;
            }) => void, rev: 2) => () => void;
            dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
            dev_get_atom_state: (a: Atom<unknown>) => ({
                d: Map<Atom<unknown>, any & ({
                    e: unknown;
                } | {
                    v: unknown;
                })>;
            } & ({
                e: unknown;
            } | {
                v: unknown;
            })) | undefined;
            dev_get_mounted: (a: Atom<unknown>) => {
                l: Set<() => void>;
                t: Set<Atom<unknown>>;
                u?: (() => void) | undefined;
            } | undefined;
            dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
        } | {
            get: <Value>(atom: Atom<Value>) => Value;
            set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
            sub: (atom: Atom<unknown>, listener: () => void) => () => void;
            dev_subscribe_store?: undefined;
            dev_get_mounted_atoms?: undefined;
            dev_get_atom_state?: undefined;
            dev_get_mounted?: undefined;
            dev_restore_atoms?: undefined;
        } | null>;
    };
}, object>;
declare const PlateController: React__default.FC<jotai_x.ProviderProps<{
    activeId: string | null;
    primaryEditorIds: string[];
    editorStores: Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null>;
}>>;
declare const usePlateControllerSelectors: () => {
    activeId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string | null;
    primaryEditorIds: (options?: (string | jotai_x.UseAtomOptions) | undefined) => string[];
    editorStores: (options?: (string | jotai_x.UseAtomOptions) | undefined) => Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value_2>(atom: Atom<Value_2>) => Value_2;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null>;
} & {
    atom: <V>(atom: Atom<V>, options?: (string | jotai_x.UseAtomOptions) | undefined) => V;
};
declare const usePlateControllerActions: () => {
    activeId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string | ((prev: string | null) => string | null) | null) => void;
    primaryEditorIds: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: string[] | ((prev: string[]) => string[])) => void;
    editorStores: (options?: (string | jotai_x.UseAtomOptions) | undefined) => (args_0: Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value_2>(atom: Atom<Value_2>) => Value_2;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null> | ((prev: Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value_2>(atom: Atom<Value_2>) => Value_2;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null>) => Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value_2>(atom: Atom<Value_2>) => Value_2;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null>)) => void;
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => (...args: A) => R;
};
declare const usePlateControllerStates: () => {
    activeId: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string | null, (args_0: string | ((prev: string | null) => string | null) | null) => void];
    primaryEditorIds: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [string[], (args_0: string[] | ((prev: string[]) => string[])) => void];
    editorStores: (options?: (string | jotai_x.UseAtomOptions) | undefined) => [Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value_2>(atom: Atom<Value_2>) => Value_2;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null>, (args_0: Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value_2>(atom: Atom<Value_2>) => Value_2;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null> | ((prev: Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value_2>(atom: Atom<Value_2>) => Value_2;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null>) => Record<string, {
        get: <Value>(atom: Atom<Value>) => Value;
        set: <Value_1, Args extends unknown[], Result>(atom: jotai.WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store: (l: (action: {
            type: "write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "async-write";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "sub";
            flushed: Set<Atom<unknown>>;
        } | {
            type: "unsub";
        } | {
            type: "restore";
            flushed: Set<Atom<unknown>>;
        }) => void, rev: 2) => () => void;
        dev_get_mounted_atoms: () => IterableIterator<Atom<unknown>>;
        dev_get_atom_state: (a: Atom<unknown>) => ({
            d: Map<Atom<unknown>, any & ({
                e: unknown;
            } | {
                v: unknown;
            })>;
        } & ({
            e: unknown;
        } | {
            v: unknown;
        })) | undefined;
        dev_get_mounted: (a: Atom<unknown>) => {
            l: Set<() => void>;
            t: Set<Atom<unknown>>;
            u?: (() => void) | undefined;
        } | undefined;
        dev_restore_atoms: (values: Iterable<readonly [Atom<unknown>, unknown]>) => void;
    } | {
        get: <Value_2>(atom: Atom<Value_2>) => Value_2;
        set: <Value_1_1, Args_1 extends unknown[], Result_1>(atom: jotai.WritableAtom<Value_1_1, Args_1, Result_1>, ...args: Args_1) => Result_1;
        sub: (atom: Atom<unknown>, listener: () => void) => () => void;
        dev_subscribe_store?: undefined;
        dev_get_mounted_atoms?: undefined;
        dev_get_atom_state?: undefined;
        dev_get_mounted?: undefined;
        dev_restore_atoms?: undefined;
    } | null>)) => void];
} & {
    atom: <V, A extends unknown[], R>(atom: jotai.WritableAtom<V, A, R>, options?: (string | jotai_x.UseAtomOptions) | undefined) => [V, (...args: A) => R];
};
declare const usePlateControllerExists: () => boolean;
/**
 * Retrieve from PlateController the JotaiStore for the editor with a given
 * ID, or the active editor if no ID is provided, or the first primary editor
 * if no editor is active, or null.
 */
declare const usePlateControllerEditorStore: (idProp?: PlateId) => JotaiStore | null;

type PlateChangeKey = 'versionEditor' | 'versionSelection' | 'versionDecorate';
type PlateStoreState<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = {
    /**
     * A unique id used as a provider scope.
     * Use it if you have multiple `Plate` in the same React tree.
     * @default random id
     */
    id: PlateId;
    /**
     * Slate editor reference.
     * @default createPlateFallbackEditor()
     */
    editor: E;
    /**
     * Plugins prop passed to `Plate`.
     */
    rawPlugins: PlatePlugin<PluginOptions, V, E>[];
    /**
     * Flattened plugins.
     */
    plugins: WithPlatePlugin<PluginOptions, V, E>[];
    /**
     * Value of the editor.
     * @default [{ type: 'p', children: [{ text: '' }]}]
     */
    value: V;
} & Nullable<{
    /**
     * Whether `Editable` is rendered so slate DOM is resolvable.
     */
    isMounted: boolean;
    readOnly: boolean;
    /**
     * Whether the editor is primary. If no editor is active, then
     * PlateController will use the first-mounted primary editor.
     * @default true
     */
    primary: boolean;
    /**
     * Version incremented on each editor change.
     */
    versionEditor: number;
    /**
     * Version incremented on each editor.selection change.
     */
    versionSelection: number;
    /**
     * Version incremented when calling `redecorate`.
     * This is a dependency of the `decorate` function.
     */
    versionDecorate: number;
    /**
     * Controlled callback called when the editor state changes.
     */
    onChange: (value: V) => void;
    /**
     * Access the editor object using a React ref.
     */
    editorRef: React__default.ForwardedRef<E>;
    decorate: NonNullable<TEditableProps['decorate']>;
    renderElement: NonNullable<TEditableProps['renderElement']>;
    renderLeaf: NonNullable<TEditableProps['renderLeaf']>;
}>;
declare const EXPOSED_STORE_KEYS: (keyof PlateStoreState)[];

type PlateEditorMethods<V extends Value = Value> = {
    reset: () => void;
    redecorate: () => void;
    plate: {
        set: {
            [K in (typeof EXPOSED_STORE_KEYS)[number]]: (value: PlateStoreState<V>[K]) => void;
        };
    };
};

type PlateEditor<V extends Value = Value> = TEditor<V> & THistoryEditor<V> & TReactEditor<V> & PlateEditorMethods<V> & {
    key: any;
    plugins: WithPlatePlugin<{}, V>[];
    pluginsByKey: Record<PluginKey, WithPlatePlugin<{}, V>>;
    prevSelection: TRange | null;
    /**
     * Default block factory.
     * @default [{ type: getPluginType(editor, ELEMENT_DEFAULT), children: [{ text: '' }] }]
     */
    blockFactory: (node?: Partial<TElement>, path?: Path) => EElement<V>;
    /**
     * Editor children factory.
     * @default [editor.blockFactory()]
     */
    childrenFactory: () => V;
    /**
     * Whether the editor is a fallback editor.
     * @see {@link createPlateFallbackEditor}
     * @default false
     */
    isFallback: boolean;
    currentKeyboardEvent: React__default.KeyboardEvent | null;
};

/**
 * Node props passed by Plate
 */
interface PlateRenderNodeProps<V extends Value, E extends PlateEditor<V> = PlateEditor<V>> {
    className?: string;
    editor: E;
    /**
     * @see {@link NodeProps}
     */
    nodeProps?: AnyObject;
}

/**
 * Leaf props passed by Plate
 */
type PlateRenderLeafProps<V extends Value = Value, N extends TText = EText<V>> = PlateRenderNodeProps<V> & TRenderLeafProps<V, N>;

declare function DefaultLeaf<V extends Value>({ attributes, children, text, leaf, editor, nodeProps, ...props }: PlateRenderLeafProps<V>): React__default.JSX.Element;

declare const EditorMethodsEffect: ({ id }: {
    id?: string | undefined;
}) => null;

declare function EditorRefPluginEffect({ id, plugin, }: {
    id?: PlateId;
    plugin: WithPlatePlugin;
}): null;
declare function EditorRefEffect({ id }: {
    id?: PlateId;
}): React__default.JSX.Element;

declare const EditorStateEffect: React__default.MemoExoticComponent<({ id }: {
    id?: string | undefined;
}) => null>;

interface PlateProps<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends Partial<Pick<PlateStoreState<V, E>, 'id' | 'editor' | 'value' | 'readOnly' | 'primary'>> {
    children: React__default.ReactNode;
    decorate?: TEditableProps['decorate'];
    /**
     * If `true`, disable all the core plugins.
     * If an object, disable the core plugin properties that are `true` in the object.
     */
    disableCorePlugins?: {
        deserializeAst?: boolean;
        deserializeHtml?: boolean;
        editorProtocol?: boolean;
        eventEditor?: boolean;
        inlineVoid?: boolean;
        insertData?: boolean;
        history?: boolean;
        nodeFactory?: boolean;
        react?: boolean;
        selection?: boolean;
        length?: boolean;
    } | boolean;
    /**
     * Access the editor object using a React ref.
     */
    editorRef?: React__default.ForwardedRef<E>;
    /**
     * Initial value of the editor.
     * @default editor.childrenFactory()
     */
    initialValue?: PlateStoreState<V>['value'];
    /**
     * Specifies the maximum number of characters allowed in the editor.
     */
    maxLength?: number;
    /**
     * When `true`, it will normalize the initial value passed to the `editor` once it gets created.
     * This is useful when adding normalization rules on already existing content.
     * @default false
     */
    normalizeInitialValue?: boolean;
    /**
     * Controlled callback called when the editor state changes.
     */
    onChange?: (value: V) => void;
    plugins?: PlatePlugin[];
    renderElement?: TEditableProps['renderElement'];
    renderLeaf?: TEditableProps['renderLeaf'];
}
declare function Plate<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(props: PlateProps<V, E>): React__default.JSX.Element;

type PlateContentProps = TEditableProps & {
    /**
     * Renders the editable content.
     */
    renderEditable?: (editable: React__default.ReactElement) => React__default.ReactNode;
};
/**
 * Editable with plugins.
 *
 * - decorate prop
 * - DOM handler props
 * - readOnly prop
 * - renderAfterEditable
 * - renderBeforeEditable
 * - renderElement prop
 * - renderLeaf prop
 * - useHooks
 */
declare const PlateContent: React__default.ForwardRefExoticComponent<Omit<slate_react_dist_components_editable.EditableProps, "decorate" | "renderElement" | "renderLeaf"> & {
    decorate?: ((entry: _udecode_slate.TNodeEntry) => slate.BaseRange[]) | undefined;
    renderElement?: RenderElementFn | undefined;
    renderLeaf?: _udecode_slate_react.RenderLeafFn | undefined;
} & {
    /**
     * Renders the editable content.
     */
    renderEditable?: ((editable: React__default.ReactElement) => React__default.ReactNode) | undefined;
} & React__default.RefAttributes<unknown>>;

interface PlateControllerEffectProps {
    id?: string;
}
declare const PlateControllerEffect: ({ id: idProp, }: PlateControllerEffectProps) => null;

declare const useEditableProps: (editableProps?: TEditableProps) => TEditableProps;

type UsePlateEffectsProps<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = Pick<PlateProps<V, E>, 'id' | 'disableCorePlugins' | 'plugins'>;
declare const usePlateEffects: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>({ id, disableCorePlugins, plugins: pluginsProp, }: UsePlateEffectsProps<V, E>) => void;

/**
 * Get Slate props stored in a global store.
 */
declare const useSlateProps: <V extends Value>({ id, }: {
    id?: string | undefined;
}) => Omit<SlateProps, 'children'>;

interface PlateEffectsProps<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends UsePlateEffectsProps<V, E> {
    children: React__default.ReactNode;
}
declare function PlateEffects<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>({ children, ...props }: PlateEffectsProps<V, E>): React__default.JSX.Element;

/**
 * Slate with plugins.
 *
 * - onChange prop
 * - renderAboveSlate
 */
declare function PlateSlate({ id, children, }: {
    id?: PlateId;
    children: React__default.ReactNode;
}): React__default.ReactElement<any, string | React__default.JSXElementConstructor<any>>;

declare function PlateTest<V extends Value>({ variant, normalizeInitialValue, editableProps, ...props }: {
    variant?: 'comment' | 'wordProcessor';
    editableProps?: PlateContentProps;
} & PlateProps<V>): React__default.JSX.Element;

declare const ELEMENT_DEFAULT = "p";

declare const KEY_DESERIALIZE_AST = "deserializeAst";
/**
 * Enables support for deserializing inserted content from Slate Ast format to Slate format
 * while apply a small bug fix.
 */
declare const createDeserializeAstPlugin: <OP = _udecode_utils.AnyObject, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

declare const KEY_EDITOR_PROTOCOL = "editorProtocol";
declare const withEditorProtocol: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => E;
declare const createEditorProtocolPlugin: <OP = _udecode_utils.AnyObject, OV extends Value = Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

declare const KEY_EVENT_EDITOR = "event-editor";
declare const createEventEditorPlugin: <OP = _udecode_utils.AnyObject, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

declare const withTHistory: <V extends Value = Value, E extends TEditor<V> = TEditor<V>, EE extends E = E & Omit<slate.BaseEditor, "children" | "operations" | "marks" | "apply" | "getDirtyPaths" | "getFragment" | "markableVoid" | "normalizeNode" | "insertFragment" | "insertNode" | "isInline" | "isVoid" | "id"> & {
    id: any;
    children: V;
    operations: _udecode_slate.TOperation<_udecode_slate.TDescendant>[];
    marks: Record<string, any> | null;
    isInline: <N extends _udecode_slate.TElement>(element: N) => boolean;
    isVoid: <N_1 extends _udecode_slate.TElement>(element: N_1) => boolean;
    markableVoid: <N_2 extends _udecode_slate.TElement>(element: N_2) => boolean;
    normalizeNode: <N_3 extends _udecode_slate.TNode>(entry: _udecode_slate.TNodeEntry<N_3>) => void;
    apply: <N_4 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_4>) => void;
    getFragment: <N_5 extends _udecode_slate.TDescendant>() => N_5[];
    insertFragment: <N_6 extends _udecode_slate.TDescendant>(fragment: N_6[]) => void;
    insertNode: <N_7 extends _udecode_slate.TDescendant>(node: N_7) => void;
    getDirtyPaths: <N_8 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_8>) => slate.Path[];
} & _udecode_utils.UnknownObject & Pick<slate_history.HistoryEditor, "history" | "undo" | "redo">>(editor: E) => EE;
/**
 * @see {@link withHistory}
 */
declare const createHistoryPlugin: <OP = _udecode_utils.AnyObject, OV extends Value = Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

declare const KEY_INLINE_VOID = "inline-void";
/**
 * Merge and register all the inline types and void types from the plugins and options,
 * using `editor.isInline`, `editor.markableVoid` and `editor.isVoid`
 */
declare const withInlineVoid: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => E;
/**
 * @see {@link withInlineVoid}
 */
declare const createInlineVoidPlugin: <OP = _udecode_utils.AnyObject, OV extends Value = Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

declare const withInsertData: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => E;
declare const KEY_INSERT_DATA = "insertData";
declare const createInsertDataPlugin: <OP = _udecode_utils.AnyObject, OV extends Value = Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

type LengthPlugin = {
    maxLength: number;
};
declare const KEY_LENGTH = "length";
declare const withLength: WithOverride<LengthPlugin>;
declare const createLengthPlugin: <OP = LengthPlugin, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

declare const KEY_NODE_FACTORY = "nodeFactory";
declare const createNodeFactoryPlugin: <OP = _udecode_utils.AnyObject, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

declare const KEY_PREV_SELECTION = "prevSelection";
declare const createPrevSelectionPlugin: <OP = _udecode_utils.AnyObject, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

/**
 * @see {@link withReact}
 */
declare const createReactPlugin: <OP = _udecode_utils.AnyObject, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

interface WithPlateOptions<V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> extends Pick<PlateProps<V, E>, 'disableCorePlugins' | 'plugins' | 'maxLength'> {
    id?: any;
}
/**
 * Apply `withInlineVoid` and all plate plugins `withOverrides`.
 * Overrides:
 * - `id`: id of the editor.
 * - `key`: random key for the <Slate> component so each time the editor is created, the component resets.
 * - `options`: Plate options
 */
declare const withPlate: <V extends Value = Value, E extends TEditor<V> = TEditor<V>>(e: E, { id, plugins, disableCorePlugins, maxLength, }?: WithPlateOptions<V, E & Omit<slate.BaseEditor, "children" | "operations" | "marks" | "apply" | "getDirtyPaths" | "getFragment" | "markableVoid" | "normalizeNode" | "insertFragment" | "insertNode" | "isInline" | "isVoid" | "id"> & {
    id: any;
    children: V;
    operations: _udecode_slate.TOperation<_udecode_slate.TDescendant>[];
    marks: Record<string, any> | null;
    isInline: <N extends _udecode_slate.TElement>(element: N) => boolean;
    isVoid: <N_1 extends _udecode_slate.TElement>(element: N_1) => boolean;
    markableVoid: <N_2 extends _udecode_slate.TElement>(element: N_2) => boolean;
    normalizeNode: <N_3 extends _udecode_slate.TNode>(entry: _udecode_slate.TNodeEntry<N_3>) => void;
    apply: <N_4 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_4>) => void;
    getFragment: <N_5 extends _udecode_slate.TDescendant>() => N_5[];
    insertFragment: <N_6 extends _udecode_slate.TDescendant>(fragment: N_6[]) => void;
    insertNode: <N_7 extends _udecode_slate.TDescendant>(node: N_7) => void;
    getDirtyPaths: <N_8 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_8>) => slate.Path[];
} & _udecode_utils.UnknownObject & Pick<slate_history.HistoryEditor, "history" | "undo" | "redo"> & Pick<slate_react.ReactEditor, "insertData" | "insertFragmentData" | "insertTextData" | "setFragmentData" | "hasRange" | "hasTarget" | "hasEditableTarget" | "hasSelectableTarget" | "isTargetInsideNonReadonlyVoid"> & PlateEditorMethods<V> & {
    key: any;
    plugins: WithPlatePlugin<{}, V>[];
    pluginsByKey: Record<string, WithPlatePlugin<{}, V>>;
    prevSelection: slate.BaseRange | null;
    blockFactory: (node?: Partial<_udecode_slate.TElement> | undefined, path?: slate.Path | undefined) => _udecode_slate.ElementOf<TEditor<V>>;
    childrenFactory: () => V;
    isFallback: boolean;
    currentKeyboardEvent: React$1.KeyboardEvent<Element> | null;
}>) => E & Omit<slate.BaseEditor, "children" | "operations" | "marks" | "apply" | "getDirtyPaths" | "getFragment" | "markableVoid" | "normalizeNode" | "insertFragment" | "insertNode" | "isInline" | "isVoid" | "id"> & {
    id: any;
    children: V;
    operations: _udecode_slate.TOperation<_udecode_slate.TDescendant>[];
    marks: Record<string, any> | null;
    isInline: <N extends _udecode_slate.TElement>(element: N) => boolean;
    isVoid: <N_1 extends _udecode_slate.TElement>(element: N_1) => boolean;
    markableVoid: <N_2 extends _udecode_slate.TElement>(element: N_2) => boolean;
    normalizeNode: <N_3 extends _udecode_slate.TNode>(entry: _udecode_slate.TNodeEntry<N_3>) => void;
    apply: <N_4 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_4>) => void;
    getFragment: <N_5 extends _udecode_slate.TDescendant>() => N_5[];
    insertFragment: <N_6 extends _udecode_slate.TDescendant>(fragment: N_6[]) => void;
    insertNode: <N_7 extends _udecode_slate.TDescendant>(node: N_7) => void;
    getDirtyPaths: <N_8 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_8>) => slate.Path[];
} & _udecode_utils.UnknownObject & Pick<slate_history.HistoryEditor, "history" | "undo" | "redo"> & Pick<slate_react.ReactEditor, "insertData" | "insertFragmentData" | "insertTextData" | "setFragmentData" | "hasRange" | "hasTarget" | "hasEditableTarget" | "hasSelectableTarget" | "isTargetInsideNonReadonlyVoid"> & PlateEditorMethods<V> & {
    key: any;
    plugins: WithPlatePlugin<{}, V>[];
    pluginsByKey: Record<string, WithPlatePlugin<{}, V>>;
    prevSelection: slate.BaseRange | null;
    blockFactory: (node?: Partial<_udecode_slate.TElement> | undefined, path?: slate.Path | undefined) => _udecode_slate.ElementOf<TEditor<V>>;
    childrenFactory: () => V;
    isFallback: boolean;
    currentKeyboardEvent: React$1.KeyboardEvent<Element> | null;
};

declare const withTReact: <V extends Value = Value, E extends TEditor<V> = TEditor<V>, EE extends E = E & Omit<slate.BaseEditor, "children" | "operations" | "marks" | "apply" | "getDirtyPaths" | "getFragment" | "markableVoid" | "normalizeNode" | "insertFragment" | "insertNode" | "isInline" | "isVoid" | "id"> & {
    id: any;
    children: V;
    operations: _udecode_slate.TOperation<_udecode_slate.TDescendant>[];
    marks: Record<string, any> | null;
    isInline: <N extends _udecode_slate.TElement>(element: N) => boolean;
    isVoid: <N_1 extends _udecode_slate.TElement>(element: N_1) => boolean;
    markableVoid: <N_2 extends _udecode_slate.TElement>(element: N_2) => boolean;
    normalizeNode: <N_3 extends _udecode_slate.TNode>(entry: _udecode_slate.TNodeEntry<N_3>) => void;
    apply: <N_4 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_4>) => void;
    getFragment: <N_5 extends _udecode_slate.TDescendant>() => N_5[];
    insertFragment: <N_6 extends _udecode_slate.TDescendant>(fragment: N_6[]) => void;
    insertNode: <N_7 extends _udecode_slate.TDescendant>(node: N_7) => void;
    getDirtyPaths: <N_8 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_8>) => slate.Path[];
} & _udecode_utils.UnknownObject & Pick<slate_react.ReactEditor, "insertData" | "insertFragmentData" | "insertTextData" | "setFragmentData" | "hasRange" | "hasTarget" | "hasEditableTarget" | "hasSelectableTarget" | "isTargetInsideNonReadonlyVoid">>(editor: E) => EE;

declare const CARRIAGE_RETURN = "\r";
declare const LINE_FEED = "\n";
declare const NO_BREAK_SPACE = "\u00A0";
declare const SPACE = " ";
declare const TAB = "\t";
declare const ZERO_WIDTH_SPACE = "\u200B";

declare const KEY_DESERIALIZE_HTML = "deserializeHtml";
/**
 * Enables support for deserializing inserted content from HTML format to Slate format.
 */
declare const createDeserializeHtmlPlugin: <OP = _udecode_utils.AnyObject, OV extends _udecode_slate.Value = _udecode_slate.Value, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

type DeserializeHtmlChildren<N extends TDescendant> = ChildNode | N | string | null;
/**
 * De
 *
 */
type DeserializeHtmlNodeReturnType<N extends TDescendant> = string | null | N[] | N | DeserializeHtmlChildren<N>[];

/**
 * Replace BR elements with line feeds.
 */
declare const cleanHtmlBrElements: (rootNode: Node) => void;

/**
 * Replace \r\n and \r with \n
 */
declare const cleanHtmlCrLf: (html: string) => string;

/**
 * Remove empty elements from rootNode.
 * Allowed empty elements: BR, IMG.
 */
declare const cleanHtmlEmptyElements: (rootNode: Node) => void;

/**
 * Replace FONT elements with SPAN elements if there is textContent (remove otherwise).
 */
declare const cleanHtmlFontElements: (rootNode: Node) => void;

/**
 * Remove fragment hrefs and spans without inner text.
 */
declare const cleanHtmlLinkElements: (rootNode: Node) => void;

declare const cleanHtmlTextNodes: (rootNode: Node) => void;

/**
 * Set HTML blocks mark styles to a new child span element if any.
 * This allows Plate to use block marks.
 */
declare const copyBlockMarksToSpanChild: (rootNode: Node) => void;

type WhiteSpaceRule = 'normal' | 'pre' | 'pre-line';
type TrimStartRule = 'collapse' | 'all';
type TrimEndRule = 'collapse' | 'single-newline';
type CollapseWhiteSpaceState = {
    inlineFormattingContext: null | {
        atStart: boolean;
        lastHasTrailingWhiteSpace: boolean;
    };
    whiteSpaceRule: WhiteSpaceRule;
};

declare const collapseString: (text: string, { trimStart, trimEnd, shouldCollapseWhiteSpace, whiteSpaceIncludesNewlines, }?: {
    trimStart?: TrimStartRule | undefined;
    trimEnd?: TrimEndRule | undefined;
    shouldCollapseWhiteSpace?: boolean | undefined;
    whiteSpaceIncludesNewlines?: boolean | undefined;
}) => string;

declare const collapseWhiteSpace: (element: HTMLElement) => HTMLElement;

declare const collapseWhiteSpaceChildren: (node: Node, state: CollapseWhiteSpaceState) => void;

declare const collapseWhiteSpaceElement: (element: HTMLElement, state: CollapseWhiteSpaceState) => void;

declare const collapseWhiteSpaceNode: (node: Node, state: CollapseWhiteSpaceState) => void;

declare const collapseWhiteSpaceText: (text: Text, state: CollapseWhiteSpaceState) => void;

declare const inferWhiteSpaceRule: (element: HTMLElement) => WhiteSpaceRule | null;

declare const isLastNonEmptyTextOfInlineFormattingContext: (initialText: Text) => boolean;

declare const upsertInlineFormattingContext: (state: CollapseWhiteSpaceState) => void;
declare const endInlineFormattingContext: (state: CollapseWhiteSpaceState) => void;

/**
 * Deserialize HTML element to a valid document fragment.
 */
declare const deserializeHtml: <V extends Value>(editor: PlateEditor<V>, { element, collapseWhiteSpace: shouldCollapseWhiteSpace, }: {
    element: HTMLElement | string;
    collapseWhiteSpace?: boolean | undefined;
}) => EDescendant<V>[];

/**
 * Deserialize HTML element to fragment.
 */
declare const deserializeHtmlElement: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => DeserializeHtmlNodeReturnType<EDescendant<V>>;

/**
 * Deserialize HTML element or child node.
 */
declare const deserializeHtmlNode: <V extends Value>(editor: PlateEditor<V>) => (node: HTMLElement | ChildNode) => DeserializeHtmlNodeReturnType<EDescendant<V>>;

declare const deserializeHtmlNodeChildren: <V extends Value>(editor: PlateEditor<V>, node: HTMLElement | ChildNode) => DeserializeHtmlChildren<EDescendant<V>>[];

/**
 * Find the first HTML element that matches the given selector.
 * @param rootNode
 * @param predicate
 */
declare const findHtmlElement: (rootNode: Node, predicate: (node: HTMLElement) => boolean) => null;
declare const someHtmlElement: (rootNode: Node, predicate: (node: HTMLElement) => boolean) => boolean;

declare const getHtmlComments: (node: Node) => string[];

/**
 * Deserialize HTML body element to Fragment.
 */
declare const htmlBodyToFragment: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => EDescendant<V>[] | undefined;

/**
 * Deserialize HTML to break line.
 */
declare const htmlBrToNewLine: (node: HTMLElement | ChildNode) => "\n" | undefined;

/**
 * Deserialize HTML to Element.
 */
declare const htmlElementToElement: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => EDescendant<V> | undefined;

/**
 * Deserialize HTML to TDescendant[] with marks on Text.
 * Build the leaf from the leaf deserializers of each plugin.
 */
declare const htmlElementToLeaf: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => EDescendant<V>[];

/**
 * Convert HTML string into HTML element.
 */
declare const htmlStringToDOMNode: (rawHtml: string) => HTMLBodyElement;

declare const htmlTextNodeToString: (node: HTMLElement | ChildNode) => string | undefined;

/**
 * # Methodology
 *
 * ## Step 1. Get the list of all standard tag names
 *
 * Go to https://developer.mozilla.org/en-US/docs/Web/HTML/Element and run the
 * following in the console to generate a JSON array of tag names:
 *
 * ```js
 * JSON.stringify(
 *   Array.from(document.querySelectorAll('article table td:first-child')).map((td) => {
 *     const body = document.createElement('body');
 *     body.innerHTML = td.textContent;
 *     return body.firstChild?.tagName;
 *   }).filter((tagName) => tagName)
 * );
 * ```
 *
 * Output (as of 2023-11-06):
 *
 * ```json
 * '["BASE","LINK","META","STYLE","TITLE","ADDRESS","ARTICLE","ASIDE","FOOTER","HEADER","H1","HGROUP","MAIN","NAV","SECTION","SEARCH","BLOCKQUOTE","DD","DIV","DL","DT","FIGCAPTION","FIGURE","HR","LI","MENU","OL","P","PRE","UL","A","ABBR","B","BDI","BDO","BR","CITE","CODE","DATA","DFN","EM","I","KBD","MARK","Q","RP","RT","RUBY","S","SAMP","SMALL","SPAN","STRONG","SUB","SUP","TIME","U","VAR","WBR","AREA","AUDIO","IMG","MAP","TRACK","VIDEO","EMBED","IFRAME","OBJECT","PICTURE","PORTAL","SOURCE","svg","math","CANVAS","NOSCRIPT","SCRIPT","DEL","INS","TABLE","BUTTON","DATALIST","FIELDSET","FORM","INPUT","LABEL","LEGEND","METER","OPTGROUP","OPTION","OUTPUT","PROGRESS","SELECT","TEXTAREA","DETAILS","DIALOG","SUMMARY","SLOT","TEMPLATE","ACRONYM","BIG","CENTER","CONTENT","DIR","FONT","IMG","MARQUEE","MENUITEM","NOBR","NOEMBED","NOFRAMES","PARAM","PLAINTEXT","RB","RTC","SHADOW","STRIKE","TT","XMP"]'
 * ```
 *
 * ## Step 2. For each tag name, determine the default browser style
 *
 * Open an empty HTML file in the browser and run the following in the console:
 *
 * ```js
 * const tagNames = JSON.parse(<JSON string from step 1>);
 *
 * JSON.stringify(
 *   tagNames.filter((tagName) => {
 *     const element = document.createElement(tagName);
 *     document.body.appendChild(element);
 *     const display = window.getComputedStyle(element).display;
 *     element.remove();
 *     return display.startsWith('inline');
 *   })
 * );
 * ```
 *
 * Place the result in the array below (accurate as of 2023-11-06).
 */
declare const inlineTagNames: Set<string>;

declare const isHtmlBlockElement: (node: Node) => boolean;

declare const isHtmlComment: (node: Node) => node is Comment;

declare const isHtmlElement: (node: Node) => node is Element;

/**
 * If href starts with '#'.
 */
declare const isHtmlFragmentHref: (href: string) => boolean;

declare const isHtmlInlineElement: (node: Node) => boolean;

declare const isHtmlTable: (element: Element) => boolean;

declare const isHtmlText: (node: Node) => node is Text;

declare const isOlSymbol: (symbol: string) => boolean;

declare const parseHtmlDocument: (html: string) => Document;

declare const parseHtmlElement: (html: string) => HTMLElement;

declare const pipeDeserializeHtmlElement: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => (Nullable<DeserializeHtml> & {
    node: AnyObject;
}) | undefined;

declare const pipeDeserializeHtmlLeaf: <V extends Value>(editor: PlateEditor<V>, element: HTMLElement) => AnyObject;

/**
 * Get a deserializer by type, node names, class names and styles.
 */
declare const pluginDeserializeHtml: <V extends Value>(editor: PlateEditor<V>, plugin: WithPlatePlugin<{}, V>, { element: el, deserializeLeaf, }: {
    element: HTMLElement;
    deserializeLeaf?: boolean | undefined;
}) => (Nullable<DeserializeHtml> & {
    node: AnyObject;
}) | undefined;

/**
 * Trim the html and remove zero width spaces,
 * then wrap it with a body element.
 */
declare const postCleanHtml: (html: string) => string;

/**
 * Remove HTML surroundings and clean HTML from CR/LF
 */
declare const preCleanHtml: (html: string) => string;

/**
 * Removes HTML nodes between HTML comments.
 */
declare const removeHtmlNodesBetweenComments: (rootNode: Node, start: string, end: string) => void;

/**
 * Remove string before <html and after </html>
 */
declare const removeHtmlSurroundings: (html: string) => string;

/**
 * Replace `element` tag name by `tagName`.
 * Attributes, innerHTML and parent relationship is kept.
 */
declare const replaceTagName: (element: Element, tagName: string) => Element;

type Callback$3 = (node: Comment) => boolean;
/**
 * Traverse HTML comments.
 */
declare const traverseHtmlComments: (rootNode: Node, callback: Callback$3) => void;

type Callback$2 = (node: Element) => boolean;
/**
 * Traverse the HTML elements of the given HTML node.
 * @param rootNode The root HTML node to traverse.
 * @param callback The callback to call for each HTML element.
 */
declare const traverseHtmlElements: (rootNode: Node, callback: Callback$2) => void;

type Callback$1 = (node: Node) => boolean;
/**
 * Depth-first pre-order tree traverse the given HTML node and calls the given callback for each node.
 * see: https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)
 *
 * @param callback returns a boolean indicating whether traversal should be continued
 */
declare const traverseHtmlNode: (node: Node, callback: Callback$1) => void;

type Callback = (node: Text) => boolean;
declare const traverseHtmlTexts: (rootNode: Node, callback: Callback) => void;

/**
 * Unwrap the given HTML element.
 */
declare const unwrapHtmlElement: (element: Element) => void;

declare const resetEditor: <V extends Value>(editor: PlateEditor<V>) => void;

/**
 * Replace editor children by default block.
 */
declare const resetEditorChildren: <V extends Value>(editor: PlateEditor<V>, options?: Omit<ReplaceNodeChildrenOptions<EElement<V>, V>, "at" | "nodes"> | undefined) => void;

interface ToggleNodeTypeOptions {
    /**
     * If there is no node type above the selection, set the selected node type to activeType.
     */
    activeType?: string;
    /**
     * If there is a node type above the selection, set the selected node type to inactiveType.
     */
    inactiveType?: string;
}
/**
 * Toggle the type of the selected node.
 * Don't do anything if activeType === inactiveType.
 */
declare const toggleNodeType: <V extends Value>(editor: PlateEditor<V>, options: ToggleNodeTypeOptions, editorNodesOptions?: Omit<GetNodeEntriesOptions<V>, "match"> | undefined) => void;

interface ApplyDeepToNodesOptions<N extends TNode> {
    node: N;
    path?: Path;
    source: Record<string, any> | (() => Record<string, any>);
    apply: (node: NodeOf<N>, source: Record<string, any> | (() => Record<string, any>)) => void;
    query?: QueryNodeOptions;
}
/**
 * Recursively apply an operation to children nodes with a query.
 */
declare const applyDeepToNodes: <N extends TNode>({ node, path, source, apply, query, }: ApplyDeepToNodesOptions<N>) => void;

interface CreatePlateEditorOptions<V extends Value = Value, E extends TEditor<V> = TEditor<V>> extends Omit<WithPlateOptions<V, E & PlateEditor<V>>, 'plugins'> {
    /**
     * Initial editor (without `withPlate`).
     */
    editor?: E;
    /**
     * Editor plugins.
     */
    plugins?: PlatePlugin[];
    /**
     * Inject components into plugins.
     */
    components?: Record<string, PlatePluginComponent>;
    /**
     * Override plugins by key.
     */
    overrideByKey?: OverrideByKey;
    /**
     * Normalize editor.
     */
    normalizeInitialValue?: boolean;
}
/**
 * Create a plate editor with:
 * - `createTEditor` or custom `editor`
 * - `withPlate`
 * - custom `components`
 */
declare const createPlateEditor: <V extends Value = Value, E extends TEditor<V> = TEditor<V>>({ editor, plugins, components, overrideByKey, normalizeInitialValue: shouldNormalizeInitialValue, ...withPlateOptions }?: CreatePlateEditorOptions<V, E>) => E & Omit<slate.BaseEditor, "children" | "operations" | "marks" | "apply" | "getDirtyPaths" | "getFragment" | "markableVoid" | "normalizeNode" | "insertFragment" | "insertNode" | "isInline" | "isVoid" | "id"> & {
    id: any;
    children: V;
    operations: _udecode_slate.TOperation<_udecode_slate.TDescendant>[];
    marks: Record<string, any> | null;
    isInline: <N extends _udecode_slate.TElement>(element: N) => boolean;
    isVoid: <N_1 extends _udecode_slate.TElement>(element: N_1) => boolean;
    markableVoid: <N_2 extends _udecode_slate.TElement>(element: N_2) => boolean;
    normalizeNode: <N_3 extends _udecode_slate.TNode>(entry: _udecode_slate.TNodeEntry<N_3>) => void;
    apply: <N_4 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_4>) => void;
    getFragment: <N_5 extends _udecode_slate.TDescendant>() => N_5[];
    insertFragment: <N_6 extends _udecode_slate.TDescendant>(fragment: N_6[]) => void;
    insertNode: <N_7 extends _udecode_slate.TDescendant>(node: N_7) => void;
    getDirtyPaths: <N_8 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_8>) => slate.Path[];
} & _udecode_utils.UnknownObject & Pick<slate_history.HistoryEditor, "history" | "undo" | "redo"> & Pick<slate_react.ReactEditor, "insertData" | "insertFragmentData" | "insertTextData" | "setFragmentData" | "hasRange" | "hasTarget" | "hasEditableTarget" | "hasSelectableTarget" | "isTargetInsideNonReadonlyVoid"> & PlateEditorMethods<V> & {
    key: any;
    plugins: WithPlatePlugin<{}, V>[];
    pluginsByKey: Record<string, WithPlatePlugin<{}, V>>;
    prevSelection: slate.BaseRange | null;
    blockFactory: (node?: Partial<_udecode_slate.TElement> | undefined, path?: slate.Path | undefined) => _udecode_slate.ElementOf<TEditor<V>>;
    childrenFactory: () => V;
    isFallback: boolean;
    currentKeyboardEvent: React$1.KeyboardEvent<Element> | null;
};

declare const createPlateFallbackEditor: <V extends Value = Value, E extends TEditor<V> = TEditor<V>>(options?: CreatePlateEditorOptions<V, E>) => E & Omit<slate.BaseEditor, "children" | "operations" | "marks" | "apply" | "getDirtyPaths" | "getFragment" | "markableVoid" | "normalizeNode" | "insertFragment" | "insertNode" | "isInline" | "isVoid" | "id"> & {
    id: any;
    children: V;
    operations: _udecode_slate.TOperation<_udecode_slate.TDescendant>[];
    marks: Record<string, any> | null;
    isInline: <N extends _udecode_slate.TElement>(element: N) => boolean;
    isVoid: <N_1 extends _udecode_slate.TElement>(element: N_1) => boolean;
    markableVoid: <N_2 extends _udecode_slate.TElement>(element: N_2) => boolean;
    normalizeNode: <N_3 extends _udecode_slate.TNode>(entry: _udecode_slate.TNodeEntry<N_3>) => void;
    apply: <N_4 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_4>) => void;
    getFragment: <N_5 extends _udecode_slate.TDescendant>() => N_5[];
    insertFragment: <N_6 extends _udecode_slate.TDescendant>(fragment: N_6[]) => void;
    insertNode: <N_7 extends _udecode_slate.TDescendant>(node: N_7) => void;
    getDirtyPaths: <N_8 extends _udecode_slate.TDescendant>(operation: _udecode_slate.TOperation<N_8>) => slate.Path[];
} & _udecode_utils.UnknownObject & Pick<slate_history.HistoryEditor, "history" | "undo" | "redo"> & Pick<slate_react.ReactEditor, "insertData" | "insertFragmentData" | "insertTextData" | "setFragmentData" | "hasRange" | "hasTarget" | "hasEditableTarget" | "hasSelectableTarget" | "isTargetInsideNonReadonlyVoid"> & PlateEditorMethods<V> & {
    key: any;
    plugins: WithPlatePlugin<{}, V>[];
    pluginsByKey: Record<string, WithPlatePlugin<{}, V>>;
    prevSelection: slate.BaseRange | null;
    blockFactory: (node?: Partial<_udecode_slate.TElement> | undefined, path?: slate.Path | undefined) => _udecode_slate.ElementOf<TEditor<V>>;
    childrenFactory: () => V;
    isFallback: boolean;
    currentKeyboardEvent: React$1.KeyboardEvent<Element> | null;
};

/**
 * Create plugin factory with a default plugin.
 * - first param is the default plugin.
 * - the only required property of the default plugin is `key`.
 * - returns a plugin factory:
 *   - first param `override` can be used to (deeply) override the default plugin.
 *   - second param `overrideByKey` can be used to (deeply) override by key a nested plugin (in plugin.plugins).
 */
declare const createPluginFactory: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(defaultPlugin: PlatePlugin<NoInfer<P>, V, E>) => <OP = P, OV extends Value = V, OE extends PlateEditor<OV> = PlateEditor<OV>>(override?: Partial<PlatePlugin<NoInfer<OP>, OV, OE>> | undefined, overrideByKey?: OverrideByKey<OV, OE>) => PlatePlugin<NoInfer<OP>, OV, OE>;

/**
 * Creates a new array of plugins by overriding the plugins in the original array.
 * Components can be overridden by key using `components` in the second param.
 * Any other properties can be overridden by key using `overrideByKey` in the second param.
 */
declare const createPlugins: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugins: PlatePlugin[], { components, overrideByKey, }?: {
    /**
     * Override plugin component by key.
     */
    components?: Record<string, PlatePluginComponent> | undefined;
    /**
     * Override plugin by key.
     */
    overrideByKey?: OverrideByKey | undefined;
}) => PlatePlugin<_udecode_utils.AnyObject, V, E>[];

/**
 * Recursively merge plugin.plugins into editor.plugins and editor.pluginsByKey
 */
declare const flattenDeepPlugins: <V extends Value>(editor: PlateEditor<V>, plugins?: PlatePlugin<{}, V>[] | undefined) => void;

type InjectedPlugin<P = PluginOptions, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>> = Partial<PlatePlugin<P, V, E>>;
/**
 * Get all plugins having a defined `inject.pluginsByKey[plugin.key]`.
 * It includes `plugin` itself.
 */
declare const getInjectedPlugins: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: PlateEditor<V>, plugin: WithPlatePlugin<P, V, E>) => Partial<PlatePlugin<P, V, E>>[];

/**
 * Get plugin key by type
 */
declare const getKeyByType: <V extends Value>(editor: PlateEditor<V>, type: string) => string | undefined;

/**
 * Get plugin keys by types
 */
declare const getKeysByTypes: <V extends Value>(editor: PlateEditor<V>, type: string | string[]) => string[];

/**
 * Get plugin options by plugin key.
 */
declare const getPlugin: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, key: PluginKey) => WithPlatePlugin<P, V, E>;

declare const getPluginInjectProps: <V extends Value>(editor: PlateEditor<V>, key: PluginKey) => {
    classNames?: _udecode_utils.AnyObject | undefined;
    defaultNodeValue?: any;
    nodeKey?: string | undefined;
    query?: ((options: any, nodeProps: GetInjectPropsOptions<V>) => boolean) | undefined;
    styleKey?: keyof React$1.CSSProperties | undefined;
    transformClassName?: ((options: TransformOptions<V>) => any) | undefined;
    transformNodeValue?: ((options: TransformOptions<V>) => any) | undefined;
    transformProps?: ((options: TransformOptions<V>, props: GetInjectPropsReturnType) => _udecode_utils.AnyObject | undefined) | undefined;
    transformStyle?: ((options: TransformOptions<V>) => React$1.CSSProperties) | undefined;
    validNodeValues?: any[] | undefined;
    validTypes?: string[] | undefined;
};

declare const getPluginOptions: <P, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, key: PluginKey) => P;

/**
 * Get plugin type option by plugin key.
 */
declare const getPluginType: <V extends Value>(editor: PlateEditor<V>, key: string) => string;

/**
 * Get plugin types option by plugin keys.
 */
declare const getPluginTypes: <V extends Value>(editor: PlateEditor<V>, keys: string[]) => string[];

/**
 * Get `editor.plugins`
 */
declare const getPlugins: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E) => PlatePlugin<_udecode_utils.AnyObject, V, E>[];

/**
 * Get `editor.pluginsByKey`
 */
declare const getPluginsByKey: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor?: E | undefined) => Record<string, WithPlatePlugin<P, V, E>>;

/**
 * Override node props with plugin props.
 * `props.element.attributes` are passed as `nodeProps`.
 * Extend the class name with the node type.
 */
declare const getRenderNodeProps: <V extends Value>({ attributes, nodeProps, props, type, }: Pick<WithPlatePlugin<V>, "type" | "props"> & {
    attributes?: AnyObject | undefined;
    nodeProps: PlateRenderNodeProps<V, PlateEditor<V>>;
}) => PlateRenderNodeProps<V, PlateEditor<V>>;

declare const Hotkeys: {
    isBold: (event: React__default.KeyboardEvent) => boolean;
    isCompose: (event: React__default.KeyboardEvent) => boolean;
    isMoveBackward: (event: React__default.KeyboardEvent) => boolean;
    isMoveForward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteBackward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteForward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteLineBackward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteLineForward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteWordBackward: (event: React__default.KeyboardEvent) => boolean;
    isDeleteWordForward: (event: React__default.KeyboardEvent) => boolean;
    isExtendBackward: (event: React__default.KeyboardEvent) => boolean;
    isExtendForward: (event: React__default.KeyboardEvent) => boolean;
    isExtendLineBackward: (event: React__default.KeyboardEvent) => boolean;
    isExtendLineForward: (event: React__default.KeyboardEvent) => boolean;
    isItalic: (event: React__default.KeyboardEvent) => boolean;
    isMoveLineBackward: (event: React__default.KeyboardEvent) => boolean;
    isMoveLineForward: (event: React__default.KeyboardEvent) => boolean;
    isMoveWordBackward: (event: React__default.KeyboardEvent) => boolean;
    isMoveWordForward: (event: React__default.KeyboardEvent) => boolean;
    isRedo: (event: React__default.KeyboardEvent) => boolean;
    isSoftBreak: (event: React__default.KeyboardEvent) => boolean;
    isSplitBlock: (event: React__default.KeyboardEvent) => boolean;
    isTab: (editor: TReactEditor, event: React__default.KeyboardEvent, { composing, }?: {
        /**
         * Ignore the event if composing.
         */
        composing?: boolean | undefined;
    }) => boolean;
    isTransposeCharacter: (event: React__default.KeyboardEvent) => boolean;
    isUndo: (event: React__default.KeyboardEvent) => boolean;
    isUntab: (editor: TReactEditor, event: React__default.KeyboardEvent, { composing, }?: {
        /**
         * Ignore the event if composing.
         */
        composing?: boolean | undefined;
    }) => boolean;
};

/**
 * Map plugin inject props to injected plugin
 */
declare const mapInjectPropsToPlugin: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, plugin: WithPlatePlugin<P, V, E>, injectedPlugin: Partial<PlatePlugin>) => {
    inject: {
        pluginsByKey: Record<string, Partial<PlatePlugin>>;
    };
} | undefined;

/**
 * Recursively merge nested plugins into the root plugins
 */
declare const mergeDeepPlugins: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>, P extends WithPlatePlugin<{}, V, E> = WithPlatePlugin<{}, V, E>>(editor: E, _plugin: P) => P;

/**
 * Recursively merge a source object to children nodes with a query.
 */
declare const mergeDeepToNodes: <N extends TNode>(options: Omit<ApplyDeepToNodesOptions<N>, "apply">) => void;

declare const mockPlugin: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugin?: Partial<PlatePlugin<NoInfer<P>>> | undefined) => WithPlatePlugin<NoInfer<P>, V, E>;

/**
 * Normalize the descendants to a valid document fragment.
 */
declare const normalizeDescendantsToDocumentFragment: <V extends Value>(editor: PlateEditor<V>, { descendants }: {
    descendants: EDescendant<V>[];
}) => EDescendant<V>[];

/**
 * Normalize initial value from editor plugins. Set into plate store if diff.
 */
declare const normalizeInitialValue: <V extends Value>(editor: PlateEditor<V>, value: V) => V | undefined;

/**
 * Recursive deep merge of each plugin from `overrideByKey`
 * into plugin with same key (plugin > plugin.plugins).
 */
declare const overridePluginsByKey: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugin: PlatePlugin<NoInfer<P>, V, E>, overrideByKey?: OverrideByKey<V, E>, nested?: boolean) => PlatePlugin<NoInfer<P>, V, E>;

/**
 * @see {@link Decorate}.
 * Optimization: return undefined if empty list so Editable uses a memo.
 */
declare const pipeDecorate: (editor: PlateEditor, decorateProp?: TEditableProps['decorate']) => TEditableProps['decorate'];

declare const convertDomEventToSyntheticEvent: (domEvent: Event) => React__default.SyntheticEvent<unknown, unknown>;
/**
 * Check if an event is overrided by a handler.
 */
declare const isEventHandled: <EventType extends React__default.SyntheticEvent<unknown, unknown>>(event: EventType, handler?: ((event: EventType) => void | boolean) | undefined) => boolean;
/**
 * Generic pipe for handlers.
 * - Get all the plugins handlers by `handlerKey`.
 * - If there is no plugin handler or editable prop handler for this key, return `undefined`.
 * - Return a handler calling all the plugins handlers then the prop handler.
 * - Any handler returning true will stop the next handlers to be called, including slate internal handler.
 */
declare const pipeHandler: <V extends Value, K extends keyof DOMHandlers<V, Value, PlateEditor<Value>>>(editor: PlateEditor<V>, { editableProps, handlerKey, }: {
    editableProps?: TEditableProps | null | undefined;
    handlerKey: K;
}) => ((event: any) => void) | undefined;

/**
 * Inject plugin props, editor.
 */
declare const pipeInjectProps: <V extends Value>(editor: PlateEditor<V>, nodeProps: any) => any;

/**
 * Is the plugin disabled by another plugin.
 */
declare const pipeInsertDataQuery: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugins: Partial<PlatePlugin<P, V, E>>[], { data, dataTransfer }: PlatePluginInsertDataOptions) => boolean;

/**
 * Pipe preInsert then insertFragment.
 */
declare const pipeInsertFragment: <V extends Value>(editor: PlateEditor<V>, injectedPlugins: Partial<PlatePlugin<{}, V, PlateEditor<V>>>[], { fragment, ...options }: PlatePluginInsertDataOptions & {
    fragment: EElementOrText<V>[];
}) => void;

declare const pipeOnChange: <V extends Value>(editor: PlateEditor<V>) => (nodes: V) => boolean;

/**
 * @see {@link RenderElement}
 */
declare const pipeRenderElement: <V extends Value>(editor: PlateEditor<V>, renderElementProp?: TEditableProps['renderElement']) => TEditableProps['renderElement'];

/**
 * @see {@link RenderLeaf}
 */
declare const pipeRenderLeaf: <V extends Value>(editor: PlateEditor<V>, renderLeafProp?: TEditableProps['renderLeaf']) => TEditableProps['renderLeaf'];

/**
 * Pipe editor.insertData.transformData
 */
declare const pipeTransformData: <V extends Value>(plugins: Partial<PlatePlugin<_udecode_utils.AnyObject, V, PlateEditor<V>>>[], { data, dataTransfer }: PlatePluginInsertDataOptions) => string;

/**
 * Pipe editor.insertData.transformFragment
 */
declare const pipeTransformFragment: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugins: Partial<PlatePlugin<{}, V, E>>[], { fragment, ...options }: PlatePluginInsertDataOptions & {
    fragment: EElementOrText<V>[];
}) => EElementOrText<V>[];

/**
 * Get a `Editable.renderElement` handler for `options.type`.
 * If the type is equals to the slate element type, render `options.component`.
 * Else, return `undefined` so the pipeline can check the next plugin.
 */
declare const pluginRenderElement: <V extends Value>(editor: PlateEditor<V>, { key, type, component: _component, props }: PlatePlugin<{}, V>) => RenderElement;

/**
 * Get a `Editable.renderLeaf` handler for `options.type`.
 * If the type is equals to the slate leaf type, render `options.component`.
 * Else, return `children`.
 */
declare const pluginRenderLeaf: <V extends Value>(editor: PlateEditor<V>, { key, type, component, props }: PlatePlugin<{}, V>) => RenderLeaf;

declare const setDefaultPlugin: <P = _udecode_utils.AnyObject, V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(plugin: PlatePlugin<P, V, E>) => WithPlatePlugin<P, V, E>;

/**
 * Flatten deep plugins then set editor.plugins and editor.pluginsByKey
 */
declare const setPlatePlugins: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { disableCorePlugins, plugins: _plugins, maxLength, }: Pick<PlateProps<V, E>, "plugins" | "maxLength" | "disableCorePlugins">) => void;

type RefComponent<P, R> = React__default.FC<P> & {
    ref?: React__default.Ref<R>;
};
declare const withHOC: <ComponentProps, HOCProps, ComponentRef, HOCRef>(HOC: RefComponent<HOCProps, HOCRef>, Component: RefComponent<ComponentProps, ComponentRef>, hocProps?: Omit<HOCProps, "children"> | undefined, hocRef?: React__default.Ref<HOCRef> | undefined) => React__default.ForwardRefExoticComponent<React__default.PropsWithoutRef<ComponentProps> & React__default.RefAttributes<ComponentRef>>;

/**
 * Get slate class name: slate-<type>
 */
declare const getSlateClass: (type: string) => string;

export { ApplyDeepToNodesOptions, CARRIAGE_RETURN, CollapseWhiteSpaceState, CreatePlateEditorOptions, DOMHandler, DOMHandlerReturnType, DOMHandlers, DOM_HANDLERS, Decorate, DecorateEntry, DefaultLeaf, DeserializeHtml, DeserializeHtmlChildren, DeserializeHtmlNodeReturnType, ELEMENT_DEFAULT, EXPOSED_STORE_KEYS, EditorMethodsEffect, EditorRefEffect, EditorRefPluginEffect, EditorStateEffect, ElementProvider, ElementStoreState, EventEditorState, GLOBAL_PLATE_SCOPE, GetInjectPropsOptions, GetInjectPropsReturnType, HandlerReturnType, HotkeyPlugin, Hotkeys, InjectComponent, InjectComponentProps, InjectComponentReturnType, InjectProps, InjectedPlugin, KEY_DESERIALIZE_AST, KEY_DESERIALIZE_HTML, KEY_EDITOR_PROTOCOL, KEY_EVENT_EDITOR, KEY_INLINE_VOID, KEY_INSERT_DATA, KEY_LENGTH, KEY_NODE_FACTORY, KEY_PREV_SELECTION, KeyboardHandler, KeyboardHandlerReturnType, LINE_FEED, LengthPlugin, NO_BREAK_SPACE, NoInfer, Nullable, OnChange, OverrideByKey, PLATE_SCOPE, Plate, PlateChangeKey, PlateContent, PlateContentProps, PlateController, PlateControllerEffect, PlateControllerEffectProps, PlateEditor, PlateEditorMethods, PlateEffects, PlateEffectsProps, PlateId, PlatePlugin, PlatePluginComponent, PlatePluginInsertData, PlatePluginInsertDataOptions, PlatePluginKey, PlatePluginProps, PlateProps, PlateRenderElementProps, PlateRenderLeafProps, PlateRenderNodeProps, PlateSlate, PlateStoreProvider, PlateStoreState, PlateTest, PluginKey, PluginOptions, RenderAfterEditable, RenderElement, RenderElementFn, RenderLeaf, SCOPE_ELEMENT, SPACE, SerializeHtml, TAB, TEditableProps, TRenderElementProps, ToggleMarkPlugin, ToggleNodeTypeOptions, TransformOptions, TrimEndRule, TrimStartRule, UseEditorSelectorOptions, UsePlateEditorStoreOptions, UsePlateEffectsProps, WhiteSpaceRule, WithOverride, WithPlateOptions, WithPlatePlugin, ZERO_WIDTH_SPACE, applyDeepToNodes, cleanHtmlBrElements, cleanHtmlCrLf, cleanHtmlEmptyElements, cleanHtmlFontElements, cleanHtmlLinkElements, cleanHtmlTextNodes, collapseString, collapseWhiteSpace, collapseWhiteSpaceChildren, collapseWhiteSpaceElement, collapseWhiteSpaceNode, collapseWhiteSpaceText, convertDomEventToSyntheticEvent, copyBlockMarksToSpanChild, createDeserializeAstPlugin, createDeserializeHtmlPlugin, createEditorProtocolPlugin, createEventEditorPlugin, createHistoryPlugin, createInlineVoidPlugin, createInsertDataPlugin, createLengthPlugin, createNodeFactoryPlugin, createPlateEditor, createPlateFallbackEditor, createPlateStore, createPluginFactory, createPlugins, createPrevSelectionPlugin, createReactPlugin, deserializeHtml, deserializeHtmlElement, deserializeHtmlNode, deserializeHtmlNodeChildren, endInlineFormattingContext, eventEditorActions, eventEditorSelectors, eventEditorStore, findHtmlElement, flattenDeepPlugins, getEventPlateId, getHtmlComments, getInjectedPlugins, getKeyByType, getKeysByTypes, getPlugin, getPluginInjectProps, getPluginOptions, getPluginType, getPluginTypes, getPlugins, getPluginsByKey, getRenderNodeProps, getSlateClass, htmlBodyToFragment, htmlBrToNewLine, htmlElementToElement, htmlElementToLeaf, htmlStringToDOMNode, htmlTextNodeToString, inferWhiteSpaceRule, inlineTagNames, isEventHandled, isHtmlBlockElement, isHtmlComment, isHtmlElement, isHtmlFragmentHref, isHtmlInlineElement, isHtmlTable, isHtmlText, isLastNonEmptyTextOfInlineFormattingContext, isOlSymbol, mapInjectPropsToPlugin, mergeDeepPlugins, mergeDeepToNodes, mockPlugin, normalizeDescendantsToDocumentFragment, normalizeInitialValue, overridePluginsByKey, parseHtmlDocument, parseHtmlElement, pipeDecorate, pipeDeserializeHtmlElement, pipeDeserializeHtmlLeaf, pipeHandler, pipeInjectProps, pipeInsertDataQuery, pipeInsertFragment, pipeOnChange, pipeRenderElement, pipeRenderLeaf, pipeTransformData, pipeTransformFragment, plateControllerStore, plateStore, pluginDeserializeHtml, pluginInjectProps, pluginRenderElement, pluginRenderLeaf, postCleanHtml, preCleanHtml, removeHtmlNodesBetweenComments, removeHtmlSurroundings, replaceTagName, resetEditor, resetEditorChildren, setDefaultPlugin, setPlatePlugins, someHtmlElement, toggleNodeType, traverseHtmlComments, traverseHtmlElements, traverseHtmlNode, traverseHtmlTexts, unwrapHtmlElement, upsertInlineFormattingContext, useEditableProps, useEditorMounted, useEditorReadOnly, useEditorRef, useEditorSelection, useEditorSelector, useEditorState, useEditorVersion, useElement, useElementStore, useEventEditorSelectors, useEventPlateId, useIncrementVersion, usePlateActions, usePlateControllerActions, usePlateControllerEditorStore, usePlateControllerExists, usePlateControllerSelectors, usePlateControllerStates, usePlateControllerStore, usePlateEditorStore, usePlateEffects, usePlateId, usePlateSelectors, usePlateStates, usePlateStore, useRedecorate, useReplaceEditor, useSelectionVersion, useSlateProps, withEditorProtocol, withHOC, withInlineVoid, withInsertData, withLength, withPlate, withTHistory, withTReact };
