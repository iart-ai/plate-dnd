import * as slate_react from 'slate-react';
import * as _udecode_plate_core from '@udecode/plate-core';
import { PlateRenderElementProps, PlateRenderLeafProps, ApplyDeepToNodesOptions, PlateEditor, WithPlatePlugin, HotkeyPlugin, KeyboardHandlerReturnType, ToggleMarkPlugin } from '@udecode/plate-core';
import * as React$1 from 'react';
import React__default from 'react';
import { BoxProps, TextProps } from '@udecode/react-utils';
import { Value, TElement, EElement, TText, EText, TNode, QueryNodeOptions } from '@udecode/slate';
import { AnyObject } from '@udecode/utils';
import { TReactEditor } from '@udecode/slate-react';
import { Location } from 'slate';

type PlateElementProps<V extends Value = Value, N extends TElement = EElement<V>> = PlateRenderElementProps<V, N> & BoxProps & {
    /**
     * Get HTML attributes from Slate element. Alternative to `PlatePlugin.props`.
     */
    elementToAttributes?: (element: N) => any;
};
declare const usePlateElement: <T extends TElement = TElement>(props: PlateElementProps<Value, T>) => {
    ref: (node: any) => void;
    props: any;
};
/**
 * Headless element component.
 */
declare const PlateElement: (<V extends Value = Value, N extends TElement = EElement<V>>(props: _udecode_plate_core.PlateRenderNodeProps<V, _udecode_plate_core.PlateEditor<V>> & Omit<slate_react.RenderElementProps, "element"> & {
    element: N;
} & Omit<React__default.DetailedHTMLProps<React__default.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & {
    as?: React__default.ElementType<any> | undefined;
    asChild?: boolean | undefined;
} & React__default.RefAttributes<any> & {
    /**
     * Get HTML attributes from Slate element. Alternative to `PlatePlugin.props`.
     */
    elementToAttributes?: ((element: N) => any) | undefined;
} & React__default.RefAttributes<HTMLDivElement>) => React__default.ReactElement) & {
    displayName?: string | undefined;
};

type PlateLeafProps<V extends Value = Value, N extends TText = EText<V>> = PlateRenderLeafProps<V, N> & TextProps & {
    /**
     * Get HTML attributes from Slate leaf. Alternative to `PlatePlugin.props`.
     */
    leafToAttributes?: (leaf: N) => any;
};
declare const usePlateLeaf: <T extends TText = TText>(props: PlateLeafProps<Value, T>) => {
    ref: (node: any) => void;
    props: any;
};
/**
 * Headless leaf component.
 */
declare const PlateLeaf: (<V extends Value = Value, N extends TText = EText<V>>({ className, ...props }: _udecode_plate_core.PlateRenderNodeProps<V, _udecode_plate_core.PlateEditor<V>> & Omit<slate_react.RenderLeafProps, "leaf" | "text"> & {
    leaf: N;
    text: N;
} & Omit<React__default.DetailedHTMLProps<React__default.HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>, "ref"> & {
    as?: React__default.ElementType<any> | undefined;
    asChild?: boolean | undefined;
} & React__default.RefAttributes<any> & {
    /**
     * Get HTML attributes from Slate leaf. Alternative to `PlatePlugin.props`.
     */
    leafToAttributes?: ((leaf: N) => any) | undefined;
} & React__default.RefAttributes<HTMLSpanElement>) => React__default.ReactElement) & {
    displayName?: string | undefined;
};

declare const createNodeHOC: <V extends Value, T>(HOC: React__default.FC<T>) => (Component: any, props: T) => (childrenProps: PlateRenderElementProps<V>) => React__default.JSX.Element;

type CreateHOCOptions<T> = Partial<T> & AnyObject & {
    /**
     * Set HOC by key.
     */
    key?: string;
    /**
     * Set HOC by key.
     */
    keys?: string[];
};
/**
 * Create components HOC by plugin key.
 */
declare const createNodesHOC: <T>(HOC: React$1.FC<T>) => (components: any, options: CreateHOCOptions<T> | CreateHOCOptions<T>[]) => any;
/**
 * Create components HOC by plugin key with a custom HOC.
 */
declare const createNodesWithHOC: <T>(withHOC: (component: any, props: T) => any) => (components: any, options: CreateHOCOptions<T> | CreateHOCOptions<T>[]) => any;

/**
 * Recursively merge a source object to children nodes with a query.
 */
declare const defaultsDeepToNodes: <N extends TNode>(options: Omit<ApplyDeepToNodesOptions<N>, "apply">) => void;

/**
 * Does the node match the type provided.
 */
declare const isType: <V extends Value>(editor: PlateEditor<V>, node: any, key?: string | string[]) => boolean;

declare const onKeyDownToggleElement: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { type, options: { hotkey } }: WithPlatePlugin<HotkeyPlugin, V, E>) => KeyboardHandlerReturnType;

declare const onKeyDownToggleMark: <V extends Value = Value, E extends PlateEditor<V> = PlateEditor<V>>(editor: E, { type, options: { hotkey, clear }, }: WithPlatePlugin<ToggleMarkPlugin, V, E>) => KeyboardHandlerReturnType;

interface SelectEditorOptions {
    /**
     * Specific location if edge is not defined.
     */
    at?: Location;
    /**
     * Start or end of the editor.
     */
    edge?: 'start' | 'end';
    /**
     * If true, focus the React editor before selecting.
     */
    focus?: boolean;
}
/**
 * Select an editor at a target or an edge (start, end).
 */
declare const selectEditor: <V extends Value>(editor: TReactEditor<V>, { at, edge, focus }: SelectEditorOptions) => void;

declare const useMarkToolbarButtonState: ({ nodeType, clear, }: {
    nodeType: string;
    clear?: string | string[] | undefined;
}) => {
    pressed: boolean;
    nodeType: string;
    clear: string | string[] | undefined;
};
declare const useMarkToolbarButton: (state: ReturnType<typeof useMarkToolbarButtonState>) => {
    props: {
        pressed: boolean;
        onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => void;
        onClick: () => void;
    };
};

interface PlaceholderProps extends PlateElementProps {
    placeholder: string;
    hideOnBlur?: boolean;
    query?: QueryNodeOptions;
}
declare const usePlaceholderState: ({ hideOnBlur, query, element, }: PlaceholderProps) => {
    enabled: boolean;
};

declare const useRemoveNodeButton: ({ element }: {
    element: TElement;
}) => {
    props: {
        onMouseDown: (e: React.MouseEvent<HTMLButtonElement>) => void;
        onClick: () => void;
    };
};

type ClassNames<T> = {
    classNames?: Partial<T>;
};

type OnError = (err: any) => void;
interface ErrorHandler {
    onError?: OnError;
}

export { ClassNames, CreateHOCOptions, ErrorHandler, OnError, PlaceholderProps, PlateElement, PlateElementProps, PlateLeaf, PlateLeafProps, SelectEditorOptions, createNodeHOC, createNodesHOC, createNodesWithHOC, defaultsDeepToNodes, isType, onKeyDownToggleElement, onKeyDownToggleMark, selectEditor, useMarkToolbarButton, useMarkToolbarButtonState, usePlaceholderState, usePlateElement, usePlateLeaf, useRemoveNodeButton };
